#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_EXT_debug_printf : enable

#ifndef LOCAL_SIZE_X
#define LOCAL_SIZE_X 8
#endif
#ifndef LOCAL_SIZE_Y
#define LOCAL_SIZE_Y 8
#endif

layout(local_size_x = LOCAL_SIZE_X, local_size_y = LOCAL_SIZE_Y) in;

layout(binding = 0, rgba32f) uniform image2D posAndMaterialImage;
layout(binding = 1, rg32f) uniform image2D normalImage;

layout(binding = 2, rgba8) uniform image2D outputImage;

vec3 decodeNormal(vec2 f) {
  f = f * 2.0f - 1.0f;
  vec3 n = vec3(f.x, f.y, 1.0 - abs(f.x) - abs(f.y));
  float t = clamp(-n.z, 0.f, 1.f);
  n.x += n.x >= 0.0 ? -t : t;
  n.y += n.y >= 0.0 ? -t : t;
  return normalize(n);
}

struct PosAndMatInfo {
  vec3 hitPos;
  bool isHit;
  bool isInShadow;
  uint materialId;
};

#define HIT_BIT_OFFSET 31u
#define HIT_BIT_MASK 0x80000000u
#define SHADOW_BIT_OFFSET 30u
#define SHADOW_BIT_MASK 0x40000000
#define MATERIAL_ID_MASK 0x3FFFFFFFu
PosAndMatInfo readPosAndMatInfo(ivec2 textureCoords) {
  const vec4 data = imageLoad(posAndMaterialImage, textureCoords);
  PosAndMatInfo result;
  result.hitPos = data.xyz;
  const uint rawMat = floatBitsToUint(data.w);
  result.isHit = (HIT_BIT_MASK & rawMat) != 0;
  result.isInShadow = (SHADOW_BIT_MASK & rawMat) != 0;
  result.materialId = (rawMat & MATERIAL_ID_MASK);
  return result;
}

vec3 readNormal(ivec2 textureCoords) {
  const vec4 data = imageLoad(normalImage, textureCoords);
  return decodeNormal(data.xy);
}

void main() {
  const uint idx = gl_GlobalInvocationID.x;
  const uint idy = gl_GlobalInvocationID.y;

  ivec2 dimensions = imageSize(outputImage);
  if (idx >= dimensions.x || idy >= dimensions.y) { return; }
  const ivec2 threadTexCoords = ivec2(idx, idy);

  imageStore(outputImage, threadTexCoords, vec4(readNormal(threadTexCoords) + 0.5f * 0.5f, 1));
}