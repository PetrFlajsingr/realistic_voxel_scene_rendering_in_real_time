/**
 * Apply indirect lighting from probes from prepared buffer.
 */
#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_EXT_debug_printf : enable

#ifndef LOCAL_SIZE_X
#define LOCAL_SIZE_X 8
#endif
#ifndef LOCAL_SIZE_Y
#define LOCAL_SIZE_Y 8
#endif

layout(local_size_x = LOCAL_SIZE_X, local_size_y = LOCAL_SIZE_Y) in;

/********************************************* CONSTANTS *******************************************/
#define PI 3.141592
#define INF 10000000000000.0
#define EPSILON 0.001
#define SVO_HEADER_SIZE 2

const uint BVH_OFFSET_MASK = 0x7FFFFFFF;
const uint BVH_LEAF_NODE_MASK = ~BVH_OFFSET_MASK;

#define MAX_RAYCAST_ITERATIONS 10000

const float minThickness = 0.03; /**< Min thickness for hit */
const float maxThickness = 0.50; /**< Max thickness for hit */

const float rayBumpEpsilon = 0.001; /**< Epsilon to avoid issues when passing through edges of octahedral projection */

const float minProgressDistance = 0.01; /**< Cancel tracing if the move is smaller than this distance */

const vec2 TEX_SIZE = vec2(1024.0);
const vec2 TEX_SIZE_SMALL = vec2(64.0);

const vec2 INV_TEX_SIZE = vec2(1.0) / TEX_SIZE;
const vec2 INV_TEX_SIZE_SMALL = vec2(1.0) / TEX_SIZE_SMALL;

const uint MASK11 = 0x7FF;
const uint MASK10 = 0x3FF;
const uint R_MAX = 2047;
const uint G_MAX = 2047;
const uint G_SHIFT = 11;
const uint B_MAX = 1023;
const uint B_SHIFT = 22;

const uint DEPTH_MASK = 0xFFFF;
const uint DEPTH_MAX = 65535;

const uint NORMAL_ELEMENT_MAX = 255;
const uint NORMAL_ELEMENT_MASK = 0xFF;
const uint NORMALS_SHIFT = 16;
const uint NORMAL1_SHIFT = 0;
const uint NORMAL2_SHIFT = 8;

#define TMP_FAR 100.0
/********************************************* ENUMS *******************************************/
#define MATERIAL_TYPE uint
#define MATERIAL_TYPE_DIFFUSE 0
#define MATERIAL_TYPE_METAL 1
#define MATERIAL_TYPE_GLASS 2
#define MATERIAL_TYPE_EMIT 3
#define MATERIAL_TYPE_BLEND 4
#define MATERIAL_TYPE_MEDIA 5
#define MATERIAL_TYPE_CLOUD 6

#define TRACE_RESULT int
#define TRACE_RESULT_MISS 0
#define TRACE_RESULT_HIT 1
#define TRACE_RESULT_UNKNOWN 2

/********************************************* STRUCTS *******************************************/
/**
 * Info from pos and mat texture.
 */
struct PosAndMatInfo {
  vec3 hitPos;
  bool isHit;
  bool isInShadow;
  uint materialId;
};
/**
 * Material parameters.
 */
struct Material {
  MATERIAL_TYPE type;
  float metalness;
  float rougness;
  float specular;
  float indexOfRefraction;
  float flux;
  float emission;
  float lowDynamicRange;
  float transparency;
  float alpha;
  float density;
  float red;
  float green;
  float blue;
  float colorAlpha;
};
struct Ray {
  vec3 origin;
  float originSize;
  vec3 direction;
  float directionSize;
};
/**
 * ESVO child descriptor.
 */
struct ChildDescriptor {
  uint data1; /**< Leaf mask 8b, valid mask 8b, unused 16b */
  uint data2; /**< child pointer 32b */
};
/**
 * AABB intersection used for BVH traversal.
 */
struct AABBIntersection_ALT {
  bool hit;       /**< Hit or miss flag */
  float distance; /**< Distance to intersection */
  uint offset;    /**< Offset of child nodes */
  bool isLeaf;    /**< True if the hit node is a leaf */
};
/**
 * Model transform, AABB and material info.
 */
struct ModelInfo {
  vec4 scaleAndSvoBufferOffset; /**< .xyz is scale, floatBitsToInt(.w) is offset */
  mat4 objectMatrix;            /**< Transformation matrix */
  mat4 inverseObjectMatrix;     /**< Inverse transform matrix */
  vec4 AABB1;                   /**< xyz is p1.xyz, w is p2.x */
  vec4 AABB2;                   /**< xy is p2.yz */
  ivec4 materialsOffset;        /**< Offset of material data in material buffer */
};
/**
 * A node of BVH tree containing its AABB and children info.
 */
struct BVHNode {
  vec4 AABB1;         /**< p1.xyz, p2.x */
  vec4 AABB2leafNext; /**< p2.yz, 1bit leaf/node, 31 bit child offset/model index */
};
/**
 * ESVO tracing result.
 */
struct TraceResult {
  float distance;             /**< Hit distance in model space */
  float distanceInWorldSpace; /**< Hit distance in world space */
  vec3 pos;                   /**< Hit point position in model space */
  vec3 posInWorldSpace;       /**< Hit point position in world space */
  uint childIdx;              /**< Index of hit node within the parent */
  bool hit;                   /**< Hit or miss flag */
  int iter;                   /**< Count of iterations done in while tracing the ray */
  int stackPtr;               /**< Info about level of hit voxel within octree */
  uint materialId;            /**< ID of hit material. This is an id within this model's material buffer,
      offset needs to be applied as well */
  vec3 normal;                /**< Normal of hit point */
  bool isOnlyAABB;            /**< True of only AABB has been hit but not a voxel */
  bool aabbHit;               /**< True if aabb has been hit */
  uint objectId;              /**< ID of the hit object */
};
/********************************************* BINDINGS *******************************************/
/**
 * Texture with hit position and material index.
 */
layout(binding = 0, rgba32f) uniform image2D posAndMaterialImage;
/**
 * Texture with encoded normal.
 */
layout(binding = 1, rg32f) uniform image2D normalImage;
/**
 * Output render.
 */
layout(binding = 2, rgba8) uniform image2D outputImage;
/**
 * Buffer for all materials. Materials for a certain object can be accessed via materialID and model's offset within this buffer.
 */
layout(std430, binding = 3) buffer Materials { Material data[]; }
materials;
/**
 * Info about sun light
 */
layout(binding = 4) uniform UniformLigtValues {
  vec4 pos;           /**< Position in world space */
  vec4 ambientColor;  /**< Light's ambient color */
  vec4 diffuseColor;  /**< Light's diffuse color */
  vec4 specularColor; /**< Light's specular color */
}
light;
/**
 * Scene camera info.
 */
layout(binding = 5) uniform UniformCamera {
  vec4 pos;         /**< Position in world space */
  vec4 dir;         /**< Look direction */
  vec4 up;          /**< Up direction */
  mat4 view;        /**< Camera's view matrix */
  mat4 projection;  /**< Camera's projection matrix */
  mat4 invProjView; /**< Camera's inversion projection matrix used to bring ray into world space */
  float near;       /**< Near plane distance */
  float far;        /**< Far plane distance */
  int screenWidth;  /**< Screen resolution x */
  int screenHeight; /**< Screen resolution y */
}
camera;
/**
 * Probe image atlas.
 */
layout(binding = 6, rg32f) uniform image2DArray probeImages;
/**
 * Small depth probe atlas.
 */
layout(binding = 7, r16) uniform image2DArray probeImagesSmall;
/**
 * Proximity grid data.
 */
layout(std430, binding = 8) buffer ProxGridData { uint[] data; }
proxGrid;
/**
 * Info about proximity grid.
 */
layout(binding = 9) uniform ProxGridInfo {
  ivec4 gridSize;
  vec4 gridStep;
}
proxGridInfo;
/**
 * Information about probe grid.
 */
layout(binding = 10, std140) uniform ProbeGrid {
  ivec4 gridSize;
  vec4 gridPos;
  float gridStep;
}
grid;
/**
 * Storage for model SVOs. Offsets for each SVO are saved in model info buffer.
 * Each SVO has an info section, array of child descriptors, array of attachment pointers and an array of attachment descriptors
 */
layout(std430, binding = 11) buffer VoxelSVO_SSBO {
  //uint infoSectionPtr;
  //uint attachmentsPtr;
  //uint childDescriptors[];
  uint data[];// uint infosectionPtr, uint attachmentsPtr, childDescriptors[]
}
svo;
/**
 * Information about models.
 */
layout(std430, binding = 12) buffer SVOModelInfos { ModelInfo infos[]; }
modelInfos;
/**
 * Bounding volume hierarchy used to speed up scene traversal.
 */
layout(std430, binding = 13) buffer BVHModelAABBs { BVHNode nodes[]; }
bvh;
layout(std140, binding = 14) uniform Debug { float indirectLimit; }
debug;

/********************************************* STACK *******************************************/
#define SVO_STACK_SIZE 23
#define SVO_CAST_STACK_DEPTH SVO_STACK_SIZE
struct SvoStackData {
  int node;
  float tMax;
  uint offset;
};

SvoStackData svoStack[SVO_STACK_SIZE + 1];

#define READ_SVO_STACK(stack, idx) stack[idx]
#define WRITE_SVO_STACK(stack, idx, n, tmax, o)                                                                        \
  stack[idx].node = n;                                                                                                 \
  stack[idx].tMax = tmax;                                                                                              \
  stack[idx].offset = o

#define BVH_STACK_SIZE 23
struct BvhStackData {
  uint node;
};

#define BVH_STACK_SIZE 23
BvhStackData bvhStack[BVH_STACK_SIZE];

#define READ_BVH_STACK(stack, idx) stack[idx].node
#define WRITE_BVH_STACK(stack, idx, n) stack[idx].node = n;

/********************************************* UTIL FUNCTIONS *******************************************/
/**
 * Decode normal from octahedral projection.
 */
vec3 decodeNormal(vec2 f) {
  f = f * 2.0f - 1.0f;
  vec3 n = vec3(f.x, f.y, 1.0 - abs(f.x) - abs(f.y));
  float t = clamp(-n.z, 0.f, 1.f);
  n.x += n.x >= 0.0 ? -t : t;
  n.y += n.y >= 0.0 ? -t : t;
  return normalize(n);
}

#define HIT_BIT_OFFSET 31u
#define HIT_BIT_MASK 0x80000000u
#define SHADOW_BIT_OFFSET 30u
#define SHADOW_BIT_MASK 0x40000000
#define MATERIAL_ID_MASK 0x3FFFFFFFu
/**
 * Load hit point and material info from texture.
 */
PosAndMatInfo readPosAndMatInfo(ivec2 textureCoords) {
  const vec4 data = imageLoad(posAndMaterialImage, textureCoords);
  PosAndMatInfo result;
  result.hitPos = data.xyz;
  const uint rawMat = floatBitsToUint(data.w);
  result.isHit = (HIT_BIT_MASK & rawMat) != 0;
  result.isInShadow = (SHADOW_BIT_MASK & rawMat) != 0;
  result.materialId = (rawMat & MATERIAL_ID_MASK);
  return result;
}
/**
 * Read normal from texture and decode it.
 */
vec3 readNormal(ivec2 textureCoords) {
  const vec4 data = imageLoad(normalImage, textureCoords);
  return decodeNormal(data.xy);
}
/**
 * Find max component.
 */
float max(vec2 v) { return max(v.x, v.y); }
/**
 * Find max component.
 */
float max(vec3 v) { return max(max(v.x, v.y), v.z); }
/**
 * Find max component.
 */
float max(vec4 v) { return max(max(max(v.x, v.y), v.z), v.a); }

/**
 * Find min component.
 */
float min(vec2 v) { return min(v.x, v.y); }
/**
 * Find min component.
 */
float min(vec3 v) { return min(min(v.x, v.y), v.z); }
/**
 * Find min component.
 */
float min(vec4 v) { return min(min(min(v.x, v.y), v.z), v.a); }
/**
 * Find the biggest component.
 */
float maxComponent(vec2 a) { return max(a.x, a.y); }
/**
 * Return 1 if value is >= 0, otherwise -1
 */
float signNotZero(float f) { return (f >= 0.0) ? 1.0 : -1.0; }
/**
 * For each component return 1 if it's >= 0, -1 otherwise.
 */
vec2 signNotZero(vec2 v) { return vec2(signNotZero(v.x), signNotZero(v.y)); }
/**
 * Encode a unit vector, as a direction from point, to an octahedral projection on a plane.
 */
vec2 octEncode(in vec3 v) {
  float l1norm = abs(v.x) + abs(v.y) + abs(v.z);
  vec2 result = v.xy * (1.0 / l1norm);
  if (v.z < 0.0) { result = (1.0 - abs(result.yx)) * signNotZero(result.xy); }
  return result;
}
/**
 * Decode [-1, 1] coordinates into direction.
 */
vec3 octDecode(vec2 o) {
  vec3 v = vec3(o.x, o.y, 1.0 - abs(o.x) - abs(o.y));
  if (v.z < 0.0) { v.xy = (1.0 - abs(v.yx)) * signNotZero(v.xy); }
  return normalize(v);
}
float lengthSquared(in vec2 v) { return dot(v, v); }
float lengthSquared(in vec3 v) { return dot(v, v); }
float distanceSquared(vec2 v0, vec2 v1) {
  vec2 d = v1 - v0;
  return dot(d, d);
}
int idot(ivec3 a, ivec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }
float squaredLength(vec3 v) { return dot(v, v); }

/**
 * Swap min to a and max to b.
 */
void minSwap(inout float a, inout float b) {
  float temp = min(a, b);
  b = max(a, b);
  a = temp;
}
/**
 * Sort using swap.
 */
void sort(inout vec3 v) {
  minSwap(v[0], v[1]);
  minSwap(v[1], v[2]);
  minSwap(v[0], v[1]);
}
#define LOG_DEPTH_C 1
/**
 * Transform linear depth into logarithmic depth.
 */
float computeLogDepth(float depth) { return log(LOG_DEPTH_C * depth + 1) / log(LOG_DEPTH_C * TMP_FAR + 1); }
/**
 * Transform logarithmic depth into linear depth.
 */
float linearizeLogDepth(float logDepth) { return (pow(LOG_DEPTH_C * TMP_FAR + 1, logDepth) - 1) / LOG_DEPTH_C; }

/********************************************* INTERSECTION FUNCTIONS *******************************************/
/**
 * Calculate intersection to an AABB, which is a part of scene's BVH. Additional data are saved in the result for ease of use within a stack.
 */
AABBIntersection_ALT intersectAABBDistance_ALT(Ray ray, vec3 boxMin, vec3 boxMax, uint offset, bool isLeaf) {
  const vec3 tMin = (boxMin - ray.origin) / ray.direction;
  const vec3 tMax = (boxMax - ray.origin) / ray.direction;
  const vec3 t1 = min(tMin, tMax);
  const vec3 t2 = max(tMin, tMax);
  const float tNear = max(max(t1.x, t1.y), t1.z);
  const float tFar = min(min(t2.x, t2.y), t2.z);
  AABBIntersection_ALT result;
  result.hit = tNear > 0.f && tNear < tFar || (tNear < 0.f && tFar > 0.f);
  result.distance = tNear + float(!result.hit) * INF;
  result.offset = offset;
  result.isLeaf = isLeaf;
  return result;
}
/********************************************* SVO TRACING FUNCTIONS *******************************************/
/**
 * Trace a ray through an SVO.
 */
TraceResult trace(Ray ray, uint offsetInSVOBuffer) {
  const float epsilon = exp2(-SVO_CAST_STACK_DEPTH);
  float ray_orig_sz = ray.originSize;
  int iter = 0;

  ray.direction.x = abs(ray.direction.x) > epsilon ? ray.direction.x : (ray.direction.x >= 0 ? epsilon : -epsilon);
  ray.direction.y = abs(ray.direction.y) > epsilon ? ray.direction.y : (ray.direction.y >= 0 ? epsilon : -epsilon);
  ray.direction.z = abs(ray.direction.z) > epsilon ? ray.direction.z : (ray.direction.z >= 0 ? epsilon : -epsilon);

  vec3 distanceCoef = 1.f / -abs(ray.direction);// / 10;

  vec3 distanceBias = distanceCoef * ray.origin;

  int octantMask = 7;
  const float biasCoef = 3.0f;
  if (ray.direction.x > 0.0f) {
    octantMask ^= 1;
    distanceBias.x = biasCoef * distanceCoef.x - distanceBias.x;
  }
  if (ray.direction.y > 0.0f) {
    octantMask ^= 2;
    distanceBias.y = biasCoef * distanceCoef.y - distanceBias.y;
  }
  if (ray.direction.z > 0.0f) {
    octantMask ^= 4;
    distanceBias.z = biasCoef * distanceCoef.z - distanceBias.z;
  }

  float distanceMin = max(2.f * distanceCoef - distanceBias);
  float distanceMax = min(distanceCoef - distanceBias);
  float h = distanceMax;
  distanceMin = max(distanceMin, 0.0f);
  distanceMax = min(distanceMax, 1.0f);

  int parent = 0;
  uint nodeOffset = 0;
  ChildDescriptor childDescriptor = ChildDescriptor(0, 0);// invalid until fetched
  int idx = 0;
  vec3 pos = vec3(1.0f, 1.0f, 1.0f);
  int scale = SVO_CAST_STACK_DEPTH - 1;
  float scaleExp2 = 0.5f;// exp2f(scale - s_max)

  const float posCoef = 1.5f;
  if (posCoef * distanceCoef.x - distanceBias.x > distanceMin) {
    idx ^= 1;
    pos.x = posCoef;
  }
  if (posCoef * distanceCoef.y - distanceBias.y > distanceMin) {
    idx ^= 2;
    pos.y = posCoef;
  }
  if (posCoef * distanceCoef.z - distanceBias.z > distanceMin) {
    idx ^= 4;
    pos.z = posCoef;
  }

  TraceResult res;
  uint hitMaterial;
  bool fetch = true;

  while (scale < SVO_CAST_STACK_DEPTH) {
    iter++;
    if (iter > MAX_RAYCAST_ITERATIONS) break;

    // Fetch child descriptor unless it is already valid.
    if (fetch) {
      childDescriptor.data1 = svo.data[offsetInSVOBuffer + SVO_HEADER_SIZE + parent];
      childDescriptor.data2 = svo.data[offsetInSVOBuffer + SVO_HEADER_SIZE + parent + 1];
      fetch = false;
    }

    vec3 distanceCorner = pos * distanceCoef - distanceBias;
    float distanceCornerComponentMin = min(distanceCorner);

    int childShift = idx ^ octantMask;// permute child slots based on the mirroring
    uint childMask = childDescriptor.data1 << childShift;
    if ((childMask & 0x8000u) != 0 && distanceMin <= distanceMax) {
      // Terminate if the voxel is small enough.
      //if (distanceCornerComponentMin * ray.directionSize + ray_orig_sz >= scaleExp2) {
      //    color = lut[childShift] * 0.5 + 0.1;
      //    break;// at distanceMin
      //}
      //color = vec3(1, 0, 0);

      // INTERSECT
      // Intersect active t-span with the cube and evaluate
      // tx(), ty(), and tz() at the center of the voxel.

      float tvMax = min(distanceMax, distanceCornerComponentMin);
      float halfScale = scaleExp2 * 0.5f;
      vec3 distanceCenter = halfScale * distanceCoef + distanceCorner;

      if (distanceMin <= tvMax) {
        // Terminate if the corresponding bit in the non-leaf mask is not set.
        if ((childMask & 0x0080u) != 0) {
          childShift = 7 - childShift;
          vec3 norm, distanceCorner = distanceCoef * (pos + scaleExp2) - distanceBias;
          if (distanceCorner.x > distanceCorner.y && distanceCorner.x > distanceCorner.z) {
            norm = vec3(-1, 0, 0);
          } else if (distanceCorner.y > distanceCorner.z) {
            norm = vec3(0, -1, 0);
          } else {
            norm = vec3(0, 0, -1);
          }

          if ((octantMask & 1) == 0u) { norm.x = -norm.x; }
          if ((octantMask & 2) == 0u) { norm.y = -norm.y; }
          if ((octantMask & 4) == 0u) { norm.z = -norm.z; }
          res.normal = norm;

          uint lookupOffset = svo.data[offsetInSVOBuffer];
          uint lookupEntry = svo.data[offsetInSVOBuffer + SVO_HEADER_SIZE + lookupOffset + nodeOffset];
          uint lookupEntryMask = lookupEntry & 0xFFu;
          uint siblingOffset = bitCount(lookupEntryMask << (8 - childShift) & 0xFFu);
          uint attPtr = lookupEntry >> 8u & 0xFFFFFFu;
          attPtr += siblingOffset + svo.data[offsetInSVOBuffer + 1];
          //uint phongAttrib = svo.data[offsetInSVOBuffer + SVO_HEADER_SIZE + attPtr];
          //color = vec3((phongAttrib >> 24u & 0xFFu) / 255.f, (phongAttrib >> 16u & 0xFFu) / 255.f,
          //             (phongAttrib >> 8 & 0xFFu) / 255.f);
          hitMaterial = svo.data[offsetInSVOBuffer + SVO_HEADER_SIZE + attPtr];
          //color = lut[childShift] * 0.5f + 0.5f;

          //if ((lookupEntry & 0xFFu) != 0) {
          //    color = RED;
          //} else {
          //    color = BLUE;
          //}

          break;// at distanceMin (overridden with tv_min).
        }

        // PUSH
        // Write current parent to the stack.

        if (distanceCornerComponentMin < h) { WRITE_SVO_STACK(svoStack, scale, parent, distanceMax, nodeOffset); }
        h = distanceCornerComponentMin;

        // Find child descriptor corresponding to the current voxel.

        //uint ptr = childDescriptor.data1 >> 16u;// child pointer
        uint ptr = childDescriptor.data2;// child pointer

        /* if ((childDescriptor.childData & 0x10000) != 0) { // FAR
                                  ptr = svo.data[offsetInSVOBuffer + SVO_HEADER_SIZE + parent + int(ptr * 2)];
                                }*/

        uint validMask = (childDescriptor.data1 >> 8u) & 0xFFu;
        uint leafMask = childDescriptor.data1 & 0xFFu;

        childShift = 7 - childShift;

        validMask = validMask << (8 - childShift) & 0xFFu;
        leafMask = leafMask << (8 - childShift) & 0xFFu;

        uint ofs = bitCount(validMask) - bitCount(leafMask);

        //color = lut[ofs] * 0.5 + 0.3;
        uint offsetFromParent = ptr + ofs;
        nodeOffset = parent / 2 + offsetFromParent;
        parent = parent + int(offsetFromParent * 2);

        // Select child voxel that the ray enters first.

        idx = 0;
        scale--;
        scaleExp2 = halfScale;

        if (distanceCenter.x > distanceMin) {
          idx ^= 1;
          pos.x += scaleExp2;
        }
        if (distanceCenter.y > distanceMin) {
          idx ^= 2;
          pos.y += scaleExp2;
        }
        if (distanceCenter.z > distanceMin) {
          idx ^= 4;
          pos.z += scaleExp2;
        }

        // Update active t-span and invalidate cached child descriptor.

        distanceMax = tvMax;
        //childDescriptor.childData = 0;
        fetch = true;
        continue;
      }
    }

    // ADVANCE
    // Step along the ray.
    int stepMask = 0;
    if (distanceCorner.x <= distanceCornerComponentMin) {
      stepMask ^= 1;
      pos.x -= scaleExp2;
    }
    if (distanceCorner.y <= distanceCornerComponentMin) {
      stepMask ^= 2;
      pos.y -= scaleExp2;
    }
    if (distanceCorner.z <= distanceCornerComponentMin) {
      stepMask ^= 4;
      pos.z -= scaleExp2;
    }

    // Update active t-span and flip bits of the child slot index.

    distanceMin = distanceCornerComponentMin;
    idx ^= stepMask;

    // Proceed with pop if the bit flips disagree with the ray direction.

    if ((idx & stepMask) != 0) {
      // POP
      // Find the highest differing bit between the two positions.

      uint differingBits = 0;
      if ((stepMask & 1) != 0) differingBits |= floatBitsToInt(pos.x) ^ floatBitsToInt(pos.x + scaleExp2);
      if ((stepMask & 2) != 0) differingBits |= floatBitsToInt(pos.y) ^ floatBitsToInt(pos.y + scaleExp2);
      if ((stepMask & 4) != 0) differingBits |= floatBitsToInt(pos.z) ^ floatBitsToInt(pos.z + scaleExp2);
      scale = findMSB(differingBits);                                        // position of the highest bit
      scaleExp2 = intBitsToFloat((scale - SVO_CAST_STACK_DEPTH + 127) << 23);// exp2f(scale - s_max)

      // Restore parent voxel from the stack.

      parent = READ_SVO_STACK(svoStack, scale).node;
      distanceMax = READ_SVO_STACK(svoStack, scale).tMax;
      nodeOffset = READ_SVO_STACK(svoStack, scale).offset;

      // Round cube position and extract child slot index.

      int shx = floatBitsToInt(pos.x) >> scale;
      int shy = floatBitsToInt(pos.y) >> scale;
      int shz = floatBitsToInt(pos.z) >> scale;
      pos.x = intBitsToFloat(shx << scale);
      pos.y = intBitsToFloat(shy << scale);
      pos.z = intBitsToFloat(shz << scale);
      idx = (shx & 1) | ((shy & 1) << 1) | ((shz & 1) << 2);

      // Prevent same parent from being stored again and invalidate cached child descriptor.

      h = 0.0f;
      //childDescriptor.childData = 0;
      fetch = true;
    }
  }

  if (scale >= SVO_CAST_STACK_DEPTH || iter > MAX_RAYCAST_ITERATIONS) { distanceMin = 2.0f; }

  // Undo mirroring of the coordinate system.

  if ((octantMask & 1) == 0) pos.x = 3.0f - scaleExp2 - pos.x;
  if ((octantMask & 2) == 0) pos.y = 3.0f - scaleExp2 - pos.y;
  if ((octantMask & 4) == 0) pos.z = 3.0f - scaleExp2 - pos.z;

  // Output results.

  res.iter = iter;
  res.pos.x = min(max(ray.origin.x + distanceMin * ray.direction.x, pos.x + epsilon), pos.x + scaleExp2 - epsilon);
  res.pos.y = min(max(ray.origin.y + distanceMin * ray.direction.y, pos.y + epsilon), pos.y + scaleExp2 - epsilon);
  res.pos.z = min(max(ray.origin.z + distanceMin * ray.direction.z, pos.z + epsilon), pos.z + scaleExp2 - epsilon);
  res.childIdx = idx ^ octantMask ^ 7;
  res.stackPtr = scale;
  res.materialId = hitMaterial;
  res.hit = !(scale >= SVO_CAST_STACK_DEPTH || iter > MAX_RAYCAST_ITERATIONS);
  return res;
}
/**
 * Transform a ray into an object space and trace its SVO.
 */
TraceResult traceModel(uint modelIndex, Ray ray) {
  ray.origin = (modelInfos.infos[modelIndex].inverseObjectMatrix * vec4(ray.origin, 1)).xyz;
  ray.direction =                                                                                //normalize(
      (transpose(modelInfos.infos[modelIndex].inverseObjectMatrix) * vec4(ray.direction, 0)).xyz;//);
  ray.originSize = 0.02;
  ray.directionSize = 0;
  TraceResult result;
  result.objectId = modelIndex;
  result.hit = false;
  result.iter = 0;

  ray.origin += vec3(1, 1, 1);

  result = trace(ray, floatBitsToUint(modelInfos.infos[modelIndex].scaleAndSvoBufferOffset.w));
  result.materialId += modelInfos.infos[modelIndex].materialsOffset.x;
  result.objectId = modelIndex;

  return result;
}

#define IS_BVH_NODE_LEAF(node) ((floatBitsToUint(node.AABB2leafNext.z) & BVH_LEAF_NODE_MASK) != 0)
#define GET_BVH_NODE_OFFSET(node) (floatBitsToUint(node.AABB2leafNext.z) & BVH_OFFSET_MASK)
#define GET_BVH_MIN_AABB(node) node.AABB1.xyz
#define GET_BVH_MAX_AABB(node) vec3(node.AABB1.w, node.AABB2leafNext.xy)

#define READ_BVH_STACK_ALT(stack, idx) stack[idx]
#define WRITE_BVH_STACK_ALT(stack, idx, n) stack[idx] = n;

AABBIntersection_ALT bvhStack_ALT[BVH_STACK_SIZE];
/**
 * Trace a ray through a BVH. If there is a hit trace within an SVO.
 */
TraceResult traceBVHImproved(Ray ray, uint idx, uint idy) {
  Ray aabbRay = ray;
  aabbRay.direction = normalize(aabbRay.direction);

  TraceResult result;
  result.hit = false;
  result.isOnlyAABB = true;
  result.iter = 0;
  result.normal = vec3(0);

  TraceResult bestModelResult;
  bestModelResult.hit = false;
  bestModelResult.iter = 0;
  bestModelResult.distanceInWorldSpace = INF;

  uint stackTop = 0;

  // BVH root
  uint nodeToCheckIdx = 0;
  BVHNode currentNode = bvh.nodes[nodeToCheckIdx];
  vec3 boxMin = GET_BVH_MIN_AABB(currentNode);
  vec3 boxMax = GET_BVH_MAX_AABB(currentNode);
  uint offset = GET_BVH_NODE_OFFSET(currentNode);
  AABBIntersection_ALT intersectionA =
      intersectAABBDistance_ALT(aabbRay, boxMin, boxMax, offset, IS_BVH_NODE_LEAF(currentNode));

  while (intersectionA.hit) {
    while (!intersectionA.isLeaf && intersectionA.hit) {
      nodeToCheckIdx = intersectionA.offset + 1;
      currentNode = bvh.nodes[nodeToCheckIdx];
      boxMin = GET_BVH_MIN_AABB(currentNode);
      boxMax = GET_BVH_MAX_AABB(currentNode);
      offset = GET_BVH_NODE_OFFSET(currentNode);
      AABBIntersection_ALT intersectionB =
          intersectAABBDistance_ALT(aabbRay, boxMin, boxMax, offset, IS_BVH_NODE_LEAF(currentNode));

      nodeToCheckIdx = intersectionA.offset;
      currentNode = bvh.nodes[nodeToCheckIdx];
      boxMin = GET_BVH_MIN_AABB(currentNode);
      boxMax = GET_BVH_MAX_AABB(currentNode);
      offset = GET_BVH_NODE_OFFSET(currentNode);
      intersectionA = intersectAABBDistance_ALT(aabbRay, boxMin, boxMax, offset, IS_BVH_NODE_LEAF(currentNode));

      // sort child nodes
      if (intersectionB.distance < intersectionA.distance) {
        AABBIntersection_ALT tmp = intersectionB;
        intersectionB = intersectionA;
        intersectionA = tmp;
      }
      // B is present only if both children have been hit, push it onto stack - if it's further away than the closest intersected model skip it
      if (intersectionB.hit && intersectionB.distance < bestModelResult.distanceInWorldSpace) {
        WRITE_BVH_STACK_ALT(bvhStack_ALT, stackTop++, intersectionB);
      }
      // there was no hit, read stack
      if (!intersectionA.hit && stackTop > 0) { intersectionA = READ_BVH_STACK_ALT(bvhStack_ALT, --stackTop); }
    }
    if (intersectionA.isLeaf && intersectionA.hit) {
      if (intersectionA.distance < bestModelResult.distanceInWorldSpace) {
        TraceResult modelTraceResult = traceModel(intersectionA.offset, ray);
        modelTraceResult.posInWorldSpace =
            (modelInfos.infos[modelTraceResult.objectId].objectMatrix * vec4(modelTraceResult.pos - vec3(1, 1, 1), 1))
                .xyz;
        modelTraceResult.distanceInWorldSpace = distance(ray.origin, modelTraceResult.posInWorldSpace);
        if (modelTraceResult.hit && modelTraceResult.distanceInWorldSpace < bestModelResult.distanceInWorldSpace) {
          bestModelResult = modelTraceResult;
        }
        result.iter += modelTraceResult.iter;
      }

      // stack is empty, end
      if (stackTop == 0) {
        intersectionA.hit = false;
      } else {// read stack
        intersectionA = READ_BVH_STACK_ALT(bvhStack_ALT, --stackTop);
      }
    }
  }

  if (bestModelResult.hit) {
    bestModelResult.normal = normalize(
        (transpose(modelInfos.infos[bestModelResult.objectId].objectMatrix) * vec4(bestModelResult.normal, 0)).xyz);
    bestModelResult.iter = result.iter;
    return bestModelResult;
  }
  return result;
}

/********************************************* PROBE  FUNCTIONS *******************************************/
/**
 * Transform world space probe coordinate into its index
 */
int gridCoordToProbeIndex(vec3 probeCoords) {
  return int(probeCoords.x + probeCoords.y * grid.gridSize.x + probeCoords.z * grid.gridSize.x * grid.gridSize.y);
}
/**
 * Convert world space probe coordinate to grid coordinate.
 */
ivec3 baseGridCoord(vec3 pos) {
  return clamp(ivec3((pos - grid.gridPos.xyz) / grid.gridStep), ivec3(0, 0, 0),
               ivec3(grid.gridSize.xyz) - ivec3(1, 1, 1));
}
/**
 * Convert world space probe coordinate to probe index.
 */
int baseProbeIndex(vec3 pos) { return gridCoordToProbeIndex(baseGridCoord(pos)); }
/**
 * Convert probe index to its grid coordinate.
 */
ivec3 probeIndexToGridCoord(int index) {
  ivec3 iPos;
  iPos.x = index & (grid.gridSize.x - 1);
  iPos.y = (index & ((grid.gridSize.x * grid.gridSize.y) - 1)) >> findMSB(grid.gridSize.x);
  iPos.z = index >> findMSB(grid.gridSize.x * grid.gridSize.y);

  return iPos;
}
/**
 * Find nearest probe to position.
 */
int nearestProbeIndex(vec3 pos, out vec3 probeCoords) {
  probeCoords =
      clamp(round((pos - grid.gridPos.xyz) / grid.gridStep), vec3(0, 0, 0), vec3(grid.gridSize.xyz) - vec3(1, 1, 1));
  return gridCoordToProbeIndex(probeCoords);
}
/**
 * Find nearest probe within probe box.
 */
int nearestProbeIndices(vec3 pos) {
  vec3 maxProbeCoords = vec3(grid.gridSize.xyz) - vec3(1, 1, 1);
  vec3 floatProbeCoords = (pos - grid.gridPos.xyz) / grid.gridStep;
  vec3 baseProbeCoords = clamp(floor(floatProbeCoords), vec3(0, 0, 0), maxProbeCoords);

  float minDist = TMP_FAR;
  int nearestIndex = -1;

  for (int i = 0; i < 8; ++i) {
    vec3 newProbeCoords = min(baseProbeCoords + vec3(i & 1, (i >> 1) & 1, (i >> 2) & 1), maxProbeCoords);
    float d = length(newProbeCoords - floatProbeCoords);
    if (d < minDist) {
      minDist = d;
      nearestIndex = i;
    }
  }

  return nearestIndex;
}
/**
 * Convert grid coordinate to world space coordinate.
 */
vec3 gridCoordToPosition(ivec3 c) { return grid.gridStep * vec3(c) + grid.gridPos.xyz; }
/**
 * Convert probe index to world space location.
 */
vec3 probeLocation(int index) { return gridCoordToPosition(probeIndexToGridCoord(index)); }

/**
 * Calculate probe index based on its base probe and index within box.
 */
int relativeProbeIndex(int baseProbeIndex, int relativeIndex) {
  int numProbes = grid.gridSize.x * grid.gridSize.y * grid.gridSize.z;

  ivec3 offset = ivec3(relativeIndex & 1, (relativeIndex >> 1) & 1, (relativeIndex >> 2) & 1);
  ivec3 stride = ivec3(1, grid.gridSize.x, grid.gridSize.x * grid.gridSize.y);

  return (baseProbeIndex + idot(offset, stride)) & (numProbes - 1);
}
/**
 * Select next cube index.
 */
int nextCycleIndex(int cycleIndex) { return (cycleIndex + 3) & 7; }
/********************************************* VOXEL FIELD FUNCTIONS *******************************************/
#define INVALID_PROX_IDX 0xFFFFu
#define PROX_MASK 0xFFFFu
/**
 * Convert voxel field grid coordinate to index.
 */
uint gridCoordToProxGridIndex(ivec3 voxelCoord) {
  return uint(voxelCoord.x + voxelCoord.y * proxGridInfo.gridSize.x
              + voxelCoord.z * proxGridInfo.gridSize.x * proxGridInfo.gridSize.y);
}
/**
 * Calculate intersection with an AABB. if res.x < res.y then there was a hit.
 */
vec2 intersectAABB(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {
  vec3 tMin = (boxMin - rayOrigin) / rayDir;
  vec3 tMax = (boxMax - rayOrigin) / rayDir;
  vec3 t1 = min(tMin, tMax);
  vec3 t2 = max(tMin, tMax);
  float tNear = max(max(t1.x, t1.y), t1.z);
  float tFar = min(min(t2.x, t2.y), t2.z);
  return vec2(tNear, tFar);
}
/**
 * Check if a point is contained within AABB.
 */
bool isInAABB(vec3 pos, vec3 boxMin, vec3 boxMax) {
  return boxMin.x <= pos.x && boxMin.y <= pos.y && boxMin.z <= pos.z && pos.x <= boxMax.x && pos.y <= boxMax.y
      && pos.z <= boxMax.z;
}
/**
 * Find voxel grid coordinate of the nearast voxel in voxel field.
 */
ivec3 nearestVoxelGridCoord(vec3 pos) {
  return clamp(ivec3((pos - grid.gridPos.xyz) / proxGridInfo.gridStep.xyz), ivec3(0, 0, 0),
               ivec3(proxGridInfo.gridSize.xyz) - ivec3(1, 1, 1));
}
/**
 * Find nearest grid coordinate of the voxel which intersects the ray.
 */
ivec3 nearestVoxelGridCoordFirst(Ray ray) {
  const vec3 gridStart = grid.gridPos.xyz;
  const vec3 gridEnd = grid.gridPos.xyz + grid.gridSize.xyz * grid.gridStep;
  if (!isInAABB(ray.origin, gridStart, gridEnd)) {
    vec2 voxFieldIntersection = intersectAABB(ray.origin, ray.direction, gridStart, gridEnd);
    if (voxFieldIntersection.x <= voxFieldIntersection.y) {
      return nearestVoxelGridCoord(ray.origin + voxFieldIntersection.x * ray.direction);
    }
  }
  return nearestVoxelGridCoord(ray.origin);
}
/**
 * Find index of nearest voxel in voxel field.
 */
uint nearestProxVoxelIndex(vec3 pos) { return gridCoordToProxGridIndex(nearestVoxelGridCoord(pos)); }
/**
 * Find index of nearest voxel in voxel field in ray path.
 */
uint nearestProxVoxelIndexFirst(Ray ray) { return gridCoordToProxGridIndex(nearestVoxelGridCoordFirst(ray)); }
/**
 * Get index of a probe saved inside the voxel. Returns -1 if there's not a valid one.
 */
int getProxProbeIdx(uint proxIdx, uint idx) {
  uint val = (proxGrid.data[proxIdx * 2 + idx / 2] >> (16 * (idx % 2)) & PROX_MASK);
  if ((val & PROX_MASK) == INVALID_PROX_IDX) { return -1; }
  return int(val);
}

/********************************************* ATLAS READING FUNCTIONS *******************************************/
/**
 * Get depth from probe atlas.
 */
float depthFromProbe(uint data) { return linearizeLogDepth(float(data & DEPTH_MASK) / DEPTH_MAX); }
/**
 * Get depth from small probe atlas.
 */
float depthFromSmallProbe(uint data) { return linearizeLogDepth(float(data) / DEPTH_MAX); }
/**
 * Decode normal from probe data.
 */
vec3 normalFromProbe(uint data) {
  const float probeNormalEncoded1 =
      float((data >> (NORMALS_SHIFT + NORMAL1_SHIFT)) & NORMAL_ELEMENT_MASK) / NORMAL_ELEMENT_MAX;
  const float probeNormalEncoded2 =
      float((data >> (NORMALS_SHIFT + NORMAL2_SHIFT)) & NORMAL_ELEMENT_MASK) / NORMAL_ELEMENT_MAX;
  return decodeNormal(vec2(probeNormalEncoded1, probeNormalEncoded2));
}

vec3 calcLight(vec3 color, vec3 pos, vec3 normal, vec3 lightDir, bool isInShadow) {
  const vec3 LAmbient = light.ambientColor.xyz;
  if (isInShadow) { return color * LAmbient; }

  const float NoL = max(dot(normal, -lightDir), 0.0);
  const vec3 LDirectional = light.diffuseColor.xyz * NoL;
  const vec3 diffuse = (LDirectional + LAmbient);
  const float specular = dot(normalize(light.pos.xyz - pos), reflect(normalize(pos - camera.pos.xyz), normal));
  vec3 intensity = diffuse + light.specularColor.xyz * (0.25 * pow(clamp(specular, 0.0, 1.0), 200.0));
  return color * intensity;
}
/**
 * Combine indirect lighting from surrounding probes.
 */
vec3 getDiffuseIndirectForPoint(vec3 hitPoint) {
  uint nearestProx = nearestProxVoxelIndex(hitPoint);

  vec3 diffuseAlbedo = vec3(0, 0, 0);
  int hitCnt = 0;

  for (uint i = 0; i < 4; ++i) {
    int baseProbeIdx = getProxProbeIdx(nearestProx, i);
    if (baseProbeIdx == -1) { break; }
    int probeIndexInCube = baseProbeIdx;
    for (uint j = 0; j < 8; ++j) {
      const int probeIndex = relativeProbeIndex(baseProbeIdx, probeIndexInCube);
      const vec3 probePos = probeLocation(probeIndex);
      vec3 probeToHitDir = hitPoint - probePos;
      const float probeToHitDist = length(probeToHitDir);
      probeToHitDir = normalize(probeToHitDir);
      const vec2 texCoord = octEncode(probeToHitDir) * 0.5 + 0.5;

      uint savedDepthAndNormalBytes = floatBitsToUint(imageLoad(probeImages, ivec3(TEX_SIZE * texCoord, probeIndex)).y);
      float distanceFromProbeToSurface = depthFromProbe(savedDepthAndNormalBytes);
      if (distance(distanceFromProbeToSurface, probeToHitDist) < debug.indirectLimit) {
        uint savedColorBytes = floatBitsToUint(imageLoad(probeImages, ivec3(texCoord * TEX_SIZE, probeIndex)).x);
        const vec3 a =
            vec3(float(savedColorBytes & MASK11) / R_MAX, float((savedColorBytes >> G_SHIFT) & MASK11) / G_MAX,
                 float((savedColorBytes >> B_SHIFT) & MASK10) / B_MAX);
        diffuseAlbedo += a;
        ++hitCnt;
      }
      probeIndexInCube = nextCycleIndex(probeIndexInCube);
    }
  }
  if (hitCnt == 0) {
    vec3 ignore;

    int baseProbeIndex = getProxProbeIdx(nearestProx, 0);
    if (baseProbeIndex == -1) { baseProbeIndex = nearestProbeIndex(hitPoint, ignore); }
    int probeIndexInCube = 0;

    for (uint j = 0; j < 8; ++j) {
      const int probeIndex = relativeProbeIndex(baseProbeIndex, probeIndexInCube);
      const vec3 probePos = probeLocation(probeIndex);
      vec3 probeToHitDir = normalize(hitPoint - probePos);
      vec2 hitCoord = octEncode(hitPoint) * 0.5 + 0.5;

      uint savedColorBytes = floatBitsToUint(imageLoad(probeImages, ivec3(hitCoord * TEX_SIZE, probeIndex)).x);
      const vec3 a = vec3(float(savedColorBytes & MASK11) / R_MAX, float((savedColorBytes >> G_SHIFT) & MASK11) / G_MAX,
                          float((savedColorBytes >> B_SHIFT) & MASK10) / B_MAX);
      diffuseAlbedo += a;
      ++hitCnt;
      probeIndexInCube = nextCycleIndex(probeIndexInCube);
    }
  }
  if (hitCnt > 0) {
    return (diffuseAlbedo / hitCnt);
  } else {
    return vec3(1, 1, 1);
  }
}

#define MAX_REFLECT_BOUNCES 3
/**
 * Trace reflection rays using SVO.
 */
vec3 traceReflection(vec3 hitPoint, vec3 normal, vec3 incomingDir) {
  TraceResult traceResult;
  vec3 color = vec3(1, 1, 1);
  bool isDone = false;
  uint i;
  const vec3 reflectDir = reflect(incomingDir, normal);
  Ray ray;
  ray.origin = hitPoint + EPSILON * reflectDir;
  ray.direction = reflectDir * TMP_FAR;
  uint bounceCnt = 0;
  for (i = 0; i < MAX_REFLECT_BOUNCES; ++i) {
    traceResult = traceBVHImproved(ray, gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
    if (!traceResult.hit) { break; }
    const Material material =
        materials.data[/*modelInfos.infos[traceResult.objectId].materialsOffset.x + */ traceResult.materialId];
    vec3 hitPoint = traceResult.posInWorldSpace;
    const vec3 normal = traceResult.normal;
    switch (material.type) {
      case MATERIAL_TYPE_GLASS:
      case MATERIAL_TYPE_DIFFUSE: {
        const vec3 indirect = getDiffuseIndirectForPoint(hitPoint);
        const vec3 matColor = vec3(material.red, material.green, material.blue);
        color = matColor * indirect;
        isDone = true;
        break;
      }
      case MATERIAL_TYPE_METAL: {
        const float roughness = material.rougness;
        const float indexOfRefraction = material.indexOfRefraction;
        const float metalness = material.metalness;
        ray.direction = reflect(ray.direction, normal);
        ray.origin = hitPoint + ray.direction * EPSILON;
        ray.direction *= TMP_FAR;
        const vec3 indirect = getDiffuseIndirectForPoint(hitPoint);
        const vec3 matColor = vec3(material.red, material.green, material.blue);
        color += mix(vec3(0, 0, 0), mix(matColor, indirect * matColor, roughness), metalness);
        break;
      }
      case MATERIAL_TYPE_EMIT: {
        const float ldr = material.lowDynamicRange;
        const float emission = material.emission;
        const float flux = material.flux;
        const vec3 matColor = vec3(material.red, material.green, material.blue);
        color = matColor;
        isDone = true;
        break;
      }
    }
    ++bounceCnt;
    if (isDone) { break; }
  }
  if (bounceCnt == 0) { return color; }
  return color / bounceCnt;
}

void main() {
  const uint idx = gl_GlobalInvocationID.x;
  const uint idy = gl_GlobalInvocationID.y;

  ivec2 dimensions = imageSize(outputImage);
  if (idx >= dimensions.x || idy >= dimensions.y) { return; }
  const ivec2 threadTexCoords = ivec2(idx, idy);

  PosAndMatInfo posAndMatInfo = readPosAndMatInfo(threadTexCoords);
  posAndMatInfo.isInShadow = false;

  vec3 color = vec3(1, 1, 1);
  if (posAndMatInfo.isHit) {
    const vec3 normal = readNormal(threadTexCoords);
    const Material material = materials.data[posAndMatInfo.materialId];

    const vec3 lightDir = normalize(light.pos.xyz - posAndMatInfo.hitPos);
    switch (material.type) {
      case MATERIAL_TYPE_DIFFUSE: {
        const vec3 indirect = getDiffuseIndirectForPoint(posAndMatInfo.hitPos);
        const vec3 matColor = vec3(material.red, material.green, material.blue);
        color = matColor * indirect;
        if (posAndMatInfo.isInShadow) { color *= 0.35; }
        break;
      }
      case MATERIAL_TYPE_GLASS: {
        const float rougness = material.rougness;
        const float indexOfRefraction = material.indexOfRefraction;
        const float transparency = material.transparency;
        color = calcLight(vec3(material.red, material.green, material.blue), posAndMatInfo.hitPos, normal, lightDir,
                          posAndMatInfo.isInShadow);
        if (posAndMatInfo.isInShadow) { color *= 0.35; }
        break;
      }
      case MATERIAL_TYPE_METAL: {
        const float rougness = material.rougness;
        const float indexOfRefraction = material.indexOfRefraction;
        const float metalness = material.metalness;

        const vec3 hitRayDir = normalize(posAndMatInfo.hitPos - camera.pos.xyz);
        const vec3 reflColor = traceReflection(posAndMatInfo.hitPos, normal, hitRayDir);
        const vec3 matColor = vec3(material.red, material.green, material.blue);

        const vec3 indirect = getDiffuseIndirectForPoint(posAndMatInfo.hitPos);

        color = mix(mix(matColor, indirect * matColor, rougness), reflColor, metalness);
        if (posAndMatInfo.isInShadow) { color *= 0.35; }
        break;
      }
      case MATERIAL_TYPE_EMIT: {
        const float ldr = material.lowDynamicRange;
        const float emission = material.emission;
        const float flux = material.flux;
        const vec3 matColor = vec3(material.red, material.green, material.blue);
        color = matColor;
        break;
      }
    }
  }
  imageStore(outputImage, threadTexCoords, vec4(color, 1));
}