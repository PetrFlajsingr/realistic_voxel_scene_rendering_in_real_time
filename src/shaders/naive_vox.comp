#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

layout(local_size_x = 8, local_size_y = 4) in;
layout(binding = 0, rgba8) uniform image2D computeImage;

layout(binding = 1) uniform UniformCamera {
    vec4 pos;
    vec4 dir;
}
camera;

struct Box {
    vec4 pos;
    vec4 color;
};

layout(std430, binding = 2) buffer VoxelSSBO { Box boxes[]; };
layout(binding = 3) uniform UniformBoxCount { uint cnt; }
boxesCount;
layout(binding = 4) uniform UniformLigtPos { vec4 pos; }
lightPos;

#define PI 3.141592
#define Inf 10000000000000.0
#define Epsilon 0.001

#define MaxBounces 40
#define SHADOW 0.35

#define MAT_NORMAL 1
#define MAT_REFLECT 2
#define MAT_REFRACT 3

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct Material {
    vec3 color;
    int type;
};

float time = 1.0;

//////////////////////////////

vec3 Camera(in float x, in float y) {
    ivec2 dimensions = imageSize(computeImage);
    float w = dimensions.x;
    float h = dimensions.y;

    float fovX = PI / 4;
    float fovY = (h / w) * fovX;

    float _x = ((2 * x - w) / w) * tan(fovX);
    float _y = -((2 * y - h) / h) * tan(fovY);

    return vec3(_x, _y, -1.0);
}

vec3 getCameraRayDir(vec2 coord, vec3 camPos, vec3 camForward) {
    const vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));
    const vec3 camUp = normalize(cross(camForward, camRight));
    const float fPersp = 1;
    return normalize(coord.x * camRight + coord.y * camUp + camForward * fPersp);
}

vec2 normalizeScreenCoords(vec2 screenCoord, vec2 resolution) {
    vec2 result = 2.0 * (screenCoord / resolution.xy - 0.5);
    result.x *= resolution.x / float(resolution.y);
    return result;
}

bool inBoxBounds(vec3 corner, float size, vec3 position) {
    bool inside = true;
    //Put the position in the coordinate frame of the box
    position -= corner;
    //The point is inside only if all of it's components are inside
    for (int i = 0; i < 3; i++) {
        inside = inside && (position[i] > -Epsilon);
        inside = inside && (position[i] < size + Epsilon);
    }

    return inside;
}

bool checkBB(in Ray ray) {
    vec3 delta = ray.origin - vec3(21);
    float b = dot((delta * 2), ray.direction);
    float c = dot(delta, delta) - 25 * 25;

    float disc = b * b - 4 * c;
    if (disc < 0) return false;
    else
    disc = sqrt(disc);

    // Always 2 solutions when pulling the square root.
    float result1 = -b + disc;
    float result2 = -b - disc;

    return (result2 > Epsilon) ? true : ((result1 > Epsilon) ? true : false);
}

bool checkBoxBB(in Ray ray, in Box box) {
    vec3 delta = ray.origin - box.pos.xyz - vec3(0.5);
    float b = dot((delta * 2), ray.direction);
    float c = dot(delta, delta) - 1.5;

    float disc = b * b - 4 * c;
    if (disc < 0) return false;
    else
    disc = sqrt(disc);

    // Always 2 solutions when pulling the square root.
    float result1 = -b + disc;
    float result2 = -b - disc;

    return (result2 > Epsilon) ? true : ((result1 > Epsilon) ? true : false);
}

float BoxIntersectionWithBB(in Ray ray, in Box box) {
    if (!checkBB(ray) || !checkBoxBB(ray, box)) { return 0; }

    //calculate opposite corner
    vec3 corner0 = box.pos.xyz;
    vec3 corner1 = corner0 + vec3(1);

    //Set the ray plane intersections
    float coeffs[6];
    coeffs[0] = (corner0.x - ray.origin.x) / (ray.direction.x);
    coeffs[1] = (corner0.y - ray.origin.y) / (ray.direction.y);
    coeffs[2] = (corner0.z - ray.origin.z) / (ray.direction.z);
    coeffs[3] = (corner1.x - ray.origin.x) / (ray.direction.x);
    coeffs[4] = (corner1.y - ray.origin.y) / (ray.direction.y);
    coeffs[5] = (corner1.z - ray.origin.z) / (ray.direction.z);

    float t = 1.f / 0.f;
    //Check for the smallest valid intersection distance
    for (uint i = 0; i < 6; i++) {
        t = coeffs[i] >= 0 && inBoxBounds(corner0, 1, ray.origin + ray.direction * coeffs[i]) ? min(coeffs[i], t) : t;
    }

    return t;
}

float boxIntersection(in Ray ray, in Box box) {
    if (!checkBB(ray) || !checkBoxBB(ray, box)) { return 0; }
    vec3 b1 = box.pos.xyz;
    vec3 b2 = b1 + vec3(1);
    bool intersect = true;
    float t1, t2, temp, tnear = -1000.0f, tfar = 1000.0f, tCube;
    for (int i = 0; i < 3; ++i) {
        if (ray.direction[i] == 0) {
            if (ray.origin[i] < b1[i] || ray.origin[i] > b2[i]) {
                intersect = false;
                break;
            }
        } else {
            t1 = (b1[i] - ray.origin[i]) / ray.direction[i];
            t2 = (b2[i] - ray.origin[i]) / ray.direction[i];
            if (t1 > t2) {
                temp = t1;
                t1 = t2;
                t2 = temp;
            }
            if (t1 > tnear) { tnear = t1; }
            if (t2 < tfar) { tfar = t2; }
            if (tnear > tfar || tfar < 0) {
                intersect = false;
                break;
            }
        }
    }
    if (!intersect) {
        tCube = -1;
    } else {
        tCube = tnear;
    }
    return tCube;
}

float floorIntersection(in Ray ray) {
    float d0 = dot(vec3(0, -1, 0), ray.direction);
    if (d0 != 0) {
        float t = -1 * (((dot(vec3(0, -1, 0), ray.origin) + 100)) / d0);
        return (t > Epsilon) ? t : 0;
    }

    return 0;
}

vec3 boxNormal(in Box box, in vec3 intersectionPoint) {
    vec3 b1 = box.pos.xyz;
    vec3 b2 = b1 + vec3(1);
    if (abs(intersectionPoint[0] - b1[0]) < Epsilon) { return vec3(-1, 0, 0); }
    if (abs(intersectionPoint[0] - b2[0]) < Epsilon) { return vec3(1, 0, 0); }
    if (abs(intersectionPoint[1] - b1[1]) < Epsilon) { return vec3(0, -1, 0); }
    if (abs(intersectionPoint[1] - b2[1]) < Epsilon) { return vec3(0, 1, 0); }
    if (abs(intersectionPoint[2] - b1[2]) < Epsilon) { return vec3(0, 0, -1); }
    if (abs(intersectionPoint[2] - b2[2]) < Epsilon) { return vec3(0, 0, 1); }
    return vec3(0);
}

bool TryGetIntersection(in Ray ray, out int id, out float distance) {
    id = -1;
    distance = Inf;

    float floorDist = floorIntersection(ray);
    if (floorDist > Epsilon) {
        distance = floorDist;
        id = -10;
    }

    for (int i = 0; i < boxesCount.cnt; i++) {
        Box s = boxes[i];
        float dist = boxIntersection(ray, s);
        if (dist > Epsilon && dist < distance) {
            distance = dist;
            id = i;
        }
    }

    return (id != -1) ? true : false;
}

float GetShadow(in Ray ray, in int id, in float maxDist) {
    float distance = Inf;

    //float floorDist = floorIntersection(ray);
    //if (floorDist > Epsilon) {
    //    distance = floorDist;
    //}

    for (int i = 0; i < boxesCount.cnt; i++) {
        Box s = boxes[i];
        if (i == id) continue;

        float dist = boxIntersection(ray, s);
        if (dist > Epsilon && dist < distance) { distance = dist; }
    }

    if (distance < maxDist) return SHADOW;

    return 1.0;
}

void ReflectRay(inout Ray ray, in vec3 hitNormal, in Material mat) {
    // Specular BRDF
    if (mat.type == MAT_REFLECT) {
        float cost = dot(ray.direction, hitNormal);
        vec3 direction = (ray.direction - hitNormal * (cost * 2));
        ray.direction = normalize(direction);
    }
}

void RefractRay(inout Ray ray, in vec3 hitNormal, in Material mat) {
    if (mat.type == MAT_REFRACT) {
        float eta = 1.1;
        if (dot(ray.direction, hitNormal) < 0) ray.direction = refract(ray.direction, hitNormal, 1.0 / eta);
        else
        ray.direction = refract(ray.direction, -hitNormal, eta);
    }
}

vec3 Light(in vec3 hitPoint) {
    if ((abs(hitPoint.y - 2.95) < 0.1) && hitPoint.x >= -0.6 && hitPoint.x <= 0.6 && hitPoint.z <= -3.05
    && hitPoint.z >= -3.45)
    return vec3(50, 50, 50);

    return vec3(0, 0, 0);
}
//////////////////////////////

vec3 Trace(inout Ray ray, out vec3 hitNormal) {
    vec3 finalColor = vec3(1.0);
    float multiplier = 1.0;

    for (int i = 0; i < MaxBounces; i++) {
        int id;
        float dist;
        bool intersection = TryGetIntersection(ray, id, dist);
        if (!intersection) {
            finalColor *= vec3(1.0) * multiplier;
            break;
        }

        Material mat;

        vec3 hitPoint = ray.origin + ray.direction * dist;
        ray.origin = hitPoint;
        if (id == -10) {
            hitNormal = vec3(0, -1, 0);
            mat = Material(vec3(0, 1, 1), MAT_NORMAL);
        } else {
            Box box = boxes[id];
            hitNormal = boxNormal(box, hitPoint);
            mat = Material(box.color.xyz, MAT_NORMAL);
        }

        vec3 emission = Light(hitPoint);
        if (length(emission) > Epsilon) return finalColor * emission * multiplier;

        ReflectRay(ray, hitNormal, mat);
        RefractRay(ray, hitNormal, mat);

        if (mat.type == MAT_NORMAL) {
            vec3 lightDir = normalize(lightPos.pos.xyz - hitPoint);
            float lightAttenuation = clamp(dot(hitNormal, lightDir), 0.1, 1.0);

            finalColor = finalColor * lightAttenuation * mat.color * multiplier;

            // Shadow Ray
            Ray shadowRay;
            shadowRay.origin = hitPoint + lightDir;
            shadowRay.direction = lightDir;
            float maxDist = length(lightPos.pos.xyz - hitPoint);

            finalColor *= GetShadow(shadowRay, id, maxDist) * multiplier;
            //

            break;
        } else {
            vec3 addColor = vec3(multiplier);
            vec3 lightDir = normalize(lightPos.pos.xyz - hitPoint);
            float lightAttenuation = clamp(dot(hitNormal, lightDir), 0.1, 1.0);

            addColor = addColor * lightAttenuation * mat.color;

            // Shadow Ray
            Ray shadowRay;
            shadowRay.origin = hitPoint;
            shadowRay.direction = lightDir;
            float maxDist = length(lightPos.pos.xyz - hitPoint);

            addColor *= GetShadow(shadowRay, id, maxDist);
            finalColor += addColor;
            multiplier *= 0.9;
        }
    }

    return finalColor;
}

void main() {
    uint idx = gl_GlobalInvocationID.x;
    uint idy = gl_GlobalInvocationID.y;

    ivec2 dimensions = imageSize(computeImage);
    if (idx > dimensions.x || idy > dimensions.y) { return; }

    Ray ray;
    ray.origin = camera.pos.xyz;
    ray.direction = getCameraRayDir(normalizeScreenCoords(vec2(idx, idy), vec2(dimensions)), ray.origin, camera.dir.xyz);

    vec3 finalColor = vec3(0.0);
    vec3 hitNormal;
    finalColor = Trace(ray, hitNormal);

    finalColor = vec3(clamp(finalColor.x, 0.0, 1.0), clamp(finalColor.y, 0.0, 1.0), clamp(finalColor.z, 0.0, 1.0));

    imageStore(computeImage, ivec2(gl_GlobalInvocationID.xy), vec4(finalColor, 0.0));
}