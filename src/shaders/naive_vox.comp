#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

layout (local_size_x = 4, local_size_y = 4) in;
layout (binding = 0, rgba8) uniform image2D computeImage;

layout(binding = 1) uniform UniformCamera {
vec4 pos;
vec4 dir;
} camera;

struct Box {
vec4 pos;
vec4 color;
};


layout(std430, binding = 2) buffer VoxelSSBO {
Box boxes[];
};
layout (binding = 3) uniform BoxCount {
    uint cnt;
} boxesCount;

#define PI 3.141592
#define Inf 10000000000000.0
#define Epsilon 0.001

#define MaxBounces 40
#define SHADOW 0.35

#define MAT_NORMAL 1
#define MAT_REFLECT 2
#define MAT_REFRACT 3

struct Ray
{
    vec3 origin;
    vec3 direction;
};

struct Material
{
    vec3 color;
    int type;
};



float time = 1.0;


//////////////////////////////

vec3 Camera (in float x, in float y)
{
    ivec2 dimensions = imageSize(computeImage);
    float w = dimensions.x;
    float h = dimensions.y;

    float fovX = PI / 4;
    float fovY = (h / w) * fovX;

    float _x = ((2 * x - w) / w) * tan(fovX);
    float _y = -((2 * y - h) / h) * tan(fovY);

    return vec3(_x, _y, -1.0);
}

vec3 getCameraRayDir(vec2 coord, vec3 camPos, vec3 camForward) {
    const vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));
    const vec3 camUp = normalize(cross(camForward, camRight));
    const float fPersp = 1;
    return normalize(coord.x * camRight + coord.y * camUp + camForward * fPersp);
}

vec2 normalizeScreenCoords(vec2 screenCoord, vec2 resolution) {
    vec2 result = 2.0 * (screenCoord/resolution.xy - 0.5);
    result.x *= resolution.x/float(resolution.y);
    return result;
}


bool inBoxBounds(vec3 corner, float size, vec3 position)
{
    bool inside = true;
    //Put the position in the coordinate frame of the box
    position -= corner;
    //The point is inside only if all of it's components are inside
    for (int i = 0; i < 3; i++)
    {
        inside = inside && (position[i] > -Epsilon);
        inside = inside && (position[i] < size + Epsilon);
    }

    return inside;
}

float BoxIntersection (in Ray ray, in Box box) {
    //calculate opposite corner
    vec3 corner0 = box.pos.xyz;
    vec3 corner1 = corner0 + vec3(1);

    //Set the ray plane intersections
    float coeffs[6];
    coeffs[0] = (corner0.x - ray.origin.x) / (ray.direction.x);
    coeffs[1] = (corner0.y - ray.origin.y) / (ray.direction.y);
    coeffs[2] = (corner0.z - ray.origin.z) / (ray.direction.z);
    coeffs[3] = (corner1.x - ray.origin.x) / (ray.direction.x);
    coeffs[4] = (corner1.y - ray.origin.y) / (ray.direction.y);
    coeffs[5] = (corner1.z - ray.origin.z) / (ray.direction.z);

    float t = 1.f/0.f;
    //Check for the smallest valid intersection distance
    for (uint i = 0; i < 6; i++) {
        t = coeffs[i] >= 0 && inBoxBounds(corner0, 1, ray.origin + ray.direction * coeffs[i]) ? min(coeffs[i], t) : t;
    }

    return t;
}


bool TryGetIntersection (in Ray ray, out int id, out float distance)
{
    id = -1;
    distance = Inf;

    for (int i = 0; i < boxesCount.cnt; i++)
    {
        Box s = boxes[i];
        float dist = BoxIntersection(ray, s);
        if (dist > Epsilon && dist < distance)
        {
            distance = dist;
            id = i;
        }
    }

    return (id > -1) ? true : false;
}

float GetShadow (in Ray ray, in int id, in float maxDist)
{
    float distance = Inf;

    for (int i = 0; i < boxes.length(); i++)
    {
        Box s = boxes[i];
        if (i == id)
        continue;

        float dist = BoxIntersection(ray, s);
        if (dist > Epsilon && dist < distance)
        {
            distance = dist;
        }
    }

    if (distance < maxDist)
    return SHADOW;

    return 1.0;
}


void ReflectRay(inout Ray ray, in vec3 hitNormal, in Material mat)
{
    // Specular BRDF
    if (mat.type == MAT_REFLECT)
    {
        float cost = dot(ray.direction, hitNormal);
        vec3 direction = (ray.direction - hitNormal * (cost * 2));
        ray.direction = normalize(direction);
    }
}

void RefractRay(inout Ray ray, in vec3 hitNormal, in Material mat) {
    if (mat.type == MAT_REFRACT) {
        float eta = 1.1;
        if (dot(ray.direction, hitNormal) < 0)
        ray.direction = refract(ray.direction, hitNormal, 1.0/eta);
        else
        ray.direction = refract(ray.direction, -hitNormal, eta);
    }
}



vec3 lightPos ()
{
    return vec3(0, -10, 0);
}


vec3 Light(in vec3 hitPoint)
{
    if ((abs(hitPoint.y - 2.95) < 0.1) && hitPoint.x >= -0.6 && hitPoint.x <= 0.6
    && hitPoint.z <= -3.05 && hitPoint.z >= -3.45)
    return vec3(50, 50, 50);

    return vec3(0, 0, 0);
}
//////////////////////////////


vec3 Trace (inout Ray ray, out vec3 hitNormal)
{
    vec3 finalColor = vec3(1.0);
    float multiplier = 1.0;

    for (int i = 0; i < MaxBounces; i++)
    {
        int id;
        float dist;
        bool intersection = TryGetIntersection(ray, id, dist);
        if (!intersection)
        {
            finalColor *= vec3(1.0) * multiplier;
            break;
        }


        Box box = boxes[id];
        vec3 hitPoint = ray.origin + ray.direction * dist;
        ray.origin = hitPoint;
        // TODO: box normal
        hitNormal = vec3(0, 1, 0);

        Material mat = Material(box.color.xyz, MAT_NORMAL);


        vec3 emission = Light(hitPoint);
        if (length(emission) > Epsilon)
        return finalColor * emission * multiplier;

        ReflectRay(ray, hitNormal, mat);
        RefractRay(ray, hitNormal, mat);

        if (mat.type == MAT_NORMAL)
        {
            vec3 lightDir = normalize(lightPos() - hitPoint);
            float lightAttenuation = clamp(dot(hitNormal, lightDir), 0.1, 1.0);

            finalColor = finalColor * lightAttenuation * mat.color * multiplier;

            // Shadow Ray
            Ray shadowRay;
            shadowRay.origin = hitPoint;
            shadowRay.direction = lightDir;
            float maxDist = length(lightPos() - hitPoint);

            finalColor *= GetShadow(shadowRay, id, maxDist) * multiplier;
            //

            break;
        } else {
            vec3 addColor = vec3(multiplier);
            vec3 lightDir = normalize(lightPos() - hitPoint);
            float lightAttenuation = clamp(dot(hitNormal, lightDir), 0.1, 1.0);

            addColor = addColor * lightAttenuation * mat.color;

            // Shadow Ray
            Ray shadowRay;
            shadowRay.origin = hitPoint;
            shadowRay.direction = lightDir;
            float maxDist = length(lightPos() - hitPoint);

            addColor *= GetShadow(shadowRay, id, maxDist);
            finalColor += addColor;
            multiplier *= 0.9;
        }
    }

    return finalColor;
}


void main()
{
    uint idx = gl_GlobalInvocationID.x;
    uint idy = gl_GlobalInvocationID.y;

    ivec2 dimensions = imageSize(computeImage);

    Ray ray;
    ray.origin = camera.pos.xyz;
    ray.direction = getCameraRayDir(normalizeScreenCoords(vec2(idx, idy), vec2(dimensions)), ray.origin, camera.dir.xyz);

    vec3 finalColor = vec3(0.0);
    vec3 hitNormal;
    finalColor = Trace(ray, hitNormal);

    finalColor = vec3(clamp(finalColor.x, 0.0, 1.0), clamp(finalColor.y, 0.0, 1.0), clamp(finalColor.z, 0.0, 1.0));

    imageStore(computeImage, ivec2(gl_GlobalInvocationID.xy), vec4(finalColor, 0.0));
}