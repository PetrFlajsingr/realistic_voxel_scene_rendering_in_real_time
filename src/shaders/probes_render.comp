#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_EXT_debug_printf : enable

#define PI 3.141592
#define INF 10000000000000.0
#define EPSILON 0.001

#ifndef LOCAL_SIZE_X
#define LOCAL_SIZE_X 8
#endif
#ifndef LOCAL_SIZE_Y
#define LOCAL_SIZE_Y 8
#endif
#ifndef LOCAL_SIZE_Z
#define LOCAL_SIZE_Z 1
#endif

bool isPrintThread() { return gl_GlobalInvocationID.x == 0 && gl_GlobalInvocationID.y == 0; }

/*if (isPrintThread()) {
  debugPrintfEXT();
}*/

const vec3 lut[8] = vec3[8](vec3(0, 0, 0),// 0
                            vec3(1, 0, 0),// 1
                            vec3(0, 1, 0),// 2
                            vec3(1, 1, 0),// 3
                            vec3(0, 0, 1),// 4
                            vec3(1, 0, 1),// 5
                            vec3(0, 1, 1),// 6
                            vec3(1, 1, 1) // 7
);

layout(local_size_x = LOCAL_SIZE_X, local_size_y = LOCAL_SIZE_Y, local_size_z = LOCAL_SIZE_Z) in;

#define PROBE_VISUAL_TYPE uint
#define PROBE_VISUAL_TYPE_DISABLED 0
#define PROBE_VISUAL_TYPE_COLOR 1
#define PROBE_VISUAL_TYPE_NORMALS 2
#define PROBE_VISUAL_TYPE_DEPTH 3
#define PROBE_VISUAL_TYPE_CAMERA_VIEW 4

layout(binding = 0, std140) uniform Debug {
  PROBE_VISUAL_TYPE probeVisualType;
  uint probeToRender;
  int debugInt;
}
debug;

layout(binding = 1, std140) uniform Grid {
  ivec4 gridSize;
  vec4 gridPos;
  float gridStep;
}
grid;

layout(binding = 2, rg32f) uniform image2DArray probeImages;
layout(binding = 3, r16) uniform image2DArray probeImagesSmall;
layout(binding = 4, rgba8) uniform image2D debugProbeImage;

layout(binding = 5) uniform UniformCamera {
  vec4 pos;
  vec4 dir;
  vec4 up;
  mat4 view;
  mat4 projection;
  mat4 invProjView;
  float near;
  float far;
  int screenWidth;
  int screenHeight;
}
camera;

vec2 normalizeScreenCoords(vec2 screenCoord, vec2 resolution) {
  vec2 result = 2.0 * (screenCoord / resolution.xy - 0.5);
  result.x *= resolution.x / float(resolution.y);
  return result;
}

struct Ray {
  vec3 origin;
  float originSize;
  vec3 direction;
  float directionSize;
};

/*
ProbeTraceResult probeTrace(Ray ray, uint probeIndex) {
  // compute polyline segments for the 4 faces which are traversed
  // for each of these segments - step by 16:1 mipmap and then do course when we get close?
  // for each pixel and thus 3D point on the segment do:
  // if ray intersects given pixel based on its radial distance
  // return ProbeTraceResult(HIT, hitpoint);
  // if ray is further away than the radial distance
  // return ProbeTraceResult(UNKNOWN, vec3());
  //return ProbeTraceResult(MISS, last endpoint of polyline);
  return ProbeTraceResult(PROBE_TRACE_STATE_UNRESOLVABLE, vec3(0));
}

void lightFieldTrace(Ray ray) {
  PROBE_TRACE_STATE result = PROBE_TRACE_STATE_UNKNOWN;
  while (result == PROBE_TRACE_STATE_UNKNOWN) {
    uint probeIndex = chooseNextProbe();
    if (probeIndex == INVALID_PROBE) {
      result = PROBE_TRACE_STATE_UNRESOLVABLE;
      break;
    }
    ProbeTraceResult probeTraceResult = probeTrace(ray, probeIndex);
    ray.origin = endpoint;
  }
}*/

/*
Probe selection:
Order in cube of probes:
    index calc: next index = (index + 3) % 8 == (index + 3) & 0xF
    0: 0 0 0 <- first probe in group
    1: x 0 0
    2: 0-y 0
    3: x-y 0
    4: 0 0 z
    5: x 0 z
    6: 0-y z
    7: x-y z
First probe: 
    select a probe so that its center is nearest the ray origin
Next probe: 
    if the new endpoint isn't in bounding box of last probe group:
        select a probe so that its center is nearest the ray origin
    else:
        select next probe in local probe box based on heuristic above
if all in group tested but returning UNKNOWN return the last occlusion as HIT

*/

const float minThickness = 0.03;// meters
const float maxThickness = 0.50;// meters

// Points exactly on the boundary in octahedral space (x = 0 and y = 0 planes) map to two different
// locations in octahedral space. We shorten the segments slightly to give unambigous locations that lead
// to intervals that lie within an octant.
const float rayBumpEpsilon = 0.001;// meters

// If we go all the way around a cell and don't move farther than this (in m)
// then we quit the trace
const float minProgressDistance = 0.01;

//  zyx bit pattern indicating which probe we're currently using within the cell on [0, 7]
#define CycleIndex int

// On [0, grid.gridSize.x * grid.gridSize.y * grid.gridSize.z - 1]
#define ProbeIndex int

// probe xyz indices
#define GridCoord ivec3

#define Point2 vec2
#define Point3 vec3

// Enumerated value
#define TraceResult int
#define TRACE_RESULT_MISS 0
#define TRACE_RESULT_HIT 1
#define TRACE_RESULT_UNKNOWN 2

float maxComponent(vec2 a) { return max(a.x, a.y); }

float signNotZero(float f) { return (f >= 0.0) ? 1.0 : -1.0; }
vec2 signNotZero(vec2 v) { return vec2(signNotZero(v.x), signNotZero(v.y)); }

/** Assumes that v is a unit vector. The result is an octahedral vector on the [-1, +1] square. */
vec2 octEncode(in vec3 v) {
  float l1norm = abs(v.x) + abs(v.y) + abs(v.z);
  vec2 result = v.xy * (1.0 / l1norm);
  if (v.z < 0.0) { result = (1.0 - abs(result.yx)) * signNotZero(result.xy); }
  return result;
}

/** Returns a unit vector. Argument o is an octahedral vector packed via octEncode,
    on the [-1, +1] square*/
vec3 octDecode(vec2 o) {
  vec3 v = vec3(o.x, o.y, 1.0 - abs(o.x) - abs(o.y));
  if (v.z < 0.0) { v.xy = (1.0 - abs(v.yx)) * signNotZero(v.xy); }
  return normalize(v);
}

float lengthSquared(in vec2 v) { return dot(v, v); }

float lengthSquared(in vec3 v) { return dot(v, v); }

float distanceSquared(Point2 v0, Point2 v1) {
  Point2 d = v1 - v0;
  return dot(d, d);
}

const vec2 TEX_SIZE = vec2(1024.0);
const vec2 TEX_SIZE_SMALL = vec2(64.0);

const vec2 INV_TEX_SIZE = vec2(1.0) / TEX_SIZE;
const vec2 INV_TEX_SIZE_SMALL = vec2(1.0) / TEX_SIZE_SMALL;

const uint MASK11 = 0x7FF;
const uint MASK10 = 0x3FF;
const uint R_MAX = 2047;
const uint G_MAX = 2047;
const uint G_SHIFT = 11;
const uint B_MAX = 1023;
const uint B_SHIFT = 22;

const uint DEPTH_MASK = 0xFFFF;
const uint DEPTH_MAX = 65535;

const uint NORMAL_ELEMENT_MAX = 255;
const uint NORMAL_ELEMENT_MASK = 0xFF;
const uint NORMALS_SHIFT = 16;
const uint NORMAL1_SHIFT = 0;
const uint NORMAL2_SHIFT = 8;

vec3 decodeNormal(vec2 f) {
  f = f * 2.0f - 1.0f;
  vec3 n = vec3(f.x, f.y, 1.0 - abs(f.x) - abs(f.y));
  float t = clamp(-n.z, 0.f, 1.f);
  n.x += n.x >= 0.0 ? -t : t;
  n.y += n.y >= 0.0 ? -t : t;
  return normalize(n);
}

#define TMP_FAR 10.0

float depthFromProbe(uint data) { return (float(data & DEPTH_MASK) / DEPTH_MAX) * TMP_FAR; }

vec3 normalFromProbe(uint data) {
  const float probeNormalEncoded1 =
      float((data >> (NORMALS_SHIFT + NORMAL1_SHIFT)) & NORMAL_ELEMENT_MASK) / NORMAL_ELEMENT_MAX;
  const float probeNormalEncoded2 =
      float((data >> (NORMALS_SHIFT + NORMAL2_SHIFT)) & NORMAL_ELEMENT_MASK) / NORMAL_ELEMENT_MAX;
  return decodeNormal(vec2(probeNormalEncoded1, probeNormalEncoded2));
}

/** 
 \param probeCoords Integer (stored in float) coordinates of the probe on the probe grid 
 */
ProbeIndex gridCoordToProbeIndex(in Point3 probeCoords) {
  return int(probeCoords.x + probeCoords.y * grid.gridSize.x + probeCoords.z * grid.gridSize.x * grid.gridSize.y);
}

GridCoord baseGridCoord(Point3 X) {
  return clamp(GridCoord((X - grid.gridPos.xyz) / grid.gridStep), GridCoord(0, 0, 0),
               GridCoord(grid.gridSize.xyz) - GridCoord(1, 1, 1));
}

/** Returns the index of the probe at the floor along each dimension. */
ProbeIndex baseProbeIndex(Point3 X) { return gridCoordToProbeIndex(baseGridCoord(X)); }

GridCoord probeIndexToGridCoord(ProbeIndex index) {
  // Assumes probeCounts are powers of two.
  // Precomputing the MSB actually slows this code down substantially
  ivec3 iPos;
  iPos.x = index & (grid.gridSize.x - 1);
  iPos.y = (index & ((grid.gridSize.x * grid.gridSize.y) - 1)) >> findMSB(grid.gridSize.x);
  iPos.z = index >> findMSB(grid.gridSize.x * grid.gridSize.y);

  return iPos;
}

/** probeCoords Coordinates of the probe, computed as part of the process. */
ProbeIndex nearestProbeIndex(Point3 X, out Point3 probeCoords) {
  probeCoords = clamp(round((X - grid.gridPos.xyz) / grid.gridStep), Point3(0, 0, 0),
                      Point3(grid.gridSize.xyz) - Point3(1, 1, 1));

  return gridCoordToProbeIndex(probeCoords);
}

/** 
    \param neighbors The 8 probes surrounding X
    \return Index into the neighbors array of the index of the nearest probe to X 
*/
CycleIndex nearestProbeIndices(Point3 X) {
  Point3 maxProbeCoords = Point3(grid.gridSize.xyz) - Point3(1, 1, 1);
  Point3 floatProbeCoords = (X - grid.gridPos.xyz) / grid.gridStep;
  Point3 baseProbeCoords = clamp(floor(floatProbeCoords), Point3(0, 0, 0), maxProbeCoords);

  float minDist = 10.0f;
  int nearestIndex = -1;

  for (int i = 0; i < 8; ++i) {
    Point3 newProbeCoords = min(baseProbeCoords + vec3(i & 1, (i >> 1) & 1, (i >> 2) & 1), maxProbeCoords);
    float d = length(newProbeCoords - floatProbeCoords);
    if (d < minDist) {
      minDist = d;
      nearestIndex = i;
    }
  }

  return nearestIndex;
}

Point3 gridCoordToPosition(GridCoord c) { return grid.gridStep * vec3(c) + grid.gridPos.xyz; }

Point3 probeLocation(ProbeIndex index) { return gridCoordToPosition(probeIndexToGridCoord(index)); }

/** GLSL's dot on ivec3 returns a float. This is an all-integer version */
int idot(ivec3 a, ivec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }

/**
   \param baseProbeIndex Index into L.radianceProbeGrid's TEXTURE_2D_ARRAY. This is the probe
   at the floor of the current ray sampling position.

   \param relativeIndex on [0, 7]. This is used as a set of three 1-bit offsets

   Returns a probe index into L.radianceProbeGrid. It may be the *same* index as 
   baseProbeIndex.

   This will wrap when the camera is outside of the probe field probes...but that's OK. 
   If that case arises, then the trace is likely to 
   be poor quality anyway. Regardless, this function will still return the index 
   of some valid probe, and that probe can either be used or fail because it does not 
   have visibility to the location desired.

   \see nextCycleIndex, baseProbeIndex
 */
ProbeIndex relativeProbeIndex(ProbeIndex baseProbeIndex, CycleIndex relativeIndex) {
  // Guaranteed to be a power of 2
  ProbeIndex numProbes = grid.gridSize.x * grid.gridSize.y * grid.gridSize.z;

  ivec3 offset = ivec3(relativeIndex & 1, (relativeIndex >> 1) & 1, (relativeIndex >> 2) & 1);
  ivec3 stride = ivec3(1, grid.gridSize.x, grid.gridSize.x * grid.gridSize.y);

  return (baseProbeIndex + idot(offset, stride)) & (numProbes - 1);
}

/** Given a CycleIndex [0, 7] on a cube of probes, returns the next CycleIndex to use. 
    \see relativeProbeIndex
*/
CycleIndex nextCycleIndex(CycleIndex cycleIndex) { return (cycleIndex + 3) & 7; }

float squaredLength(vec3 v) { return dot(v, v); }

/** Two-element sort: maybe swaps a and b so that a' = min(a, b), b' = max(a, b). */
void minSwap(inout float a, inout float b) {
  float temp = min(a, b);
  b = max(a, b);
  a = temp;
}

/** Sort the three values in v from least to 
    greatest using an exchange network (i.e., no branches) */
void sort(inout vec3 v) {
  minSwap(v[0], v[1]);
  minSwap(v[1], v[2]);
  minSwap(v[0], v[1]);
}

/** Segments a ray into the piecewise-continuous rays or line segments that each lie within
    one Euclidean octant, which correspond to piecewise-linear projections in octahedral space.
        
    \param boundaryT  all boundary distance ("time") values in units of world-space distance 
      along the ray. In the (common) case where not all five elements are needed, the unused 
      values are all equal to tMax, creating degenerate ray segments.

    \param origin Ray origin in the Euclidean object space of the probe

    \param directionFrac 1 / ray.direction
 */
void computeRaySegments(in Point3 origin, in vec3 directionFrac, in float tMin, in float tMax,
                        out float boundaryTs[5]) {

  boundaryTs[0] = tMin;

  // Time values for intersection with x = 0, y = 0, and z = 0 planes, sorted
  // in increasing order
  vec3 t = origin * -directionFrac;
  sort(t);

  // Copy the values into the interval boundaries.
  // This loop expands at compile time and eliminates the
  // relative indexing, so it is just three conditional move operations
  for (int i = 0; i < 3; ++i) { boundaryTs[i + 1] = clamp(t[i], tMin, tMax); }

  boundaryTs[4] = tMax;
}

/** Returns the distance along v from the origin to the intersection 
    with ray R (which it is assumed to intersect) */
float distanceToIntersection(in Ray R, in vec3 v) {
  float numer;
  float denom = v.y * R.direction.z - v.z * R.direction.y;

  if (abs(denom) > 0.1) {
    numer = R.origin.y * R.direction.z - R.origin.z * R.direction.y;
  } else {
    // We're in the yz plane; use another one
    numer = R.origin.x * R.direction.y - R.origin.y * R.direction.x;
    denom = v.x * R.direction.y - v.y * R.direction.x;
  }

  return numer / denom;
}

TraceResult traceSegmentHighRes(in Ray probeSpaceRay, in Point2 startTexCoord, in Point2 endTexCoord,
                                in ProbeIndex probeIndex, inout float tMin, inout float tMax,
                                inout vec2 hitProbeTexCoord) {

  vec2 texCoordDelta = endTexCoord - startTexCoord;
  float texCoordDistance = length(texCoordDelta);
  vec2 texCoordDirection = texCoordDelta * (1.0 / texCoordDistance);

  float texCoordStep = INV_TEX_SIZE.x * (texCoordDistance / maxComponent(abs(texCoordDelta)));

  vec3 directionFromProbeBefore = octDecode(startTexCoord * 2.0 - 1.0);
  float distanceFromProbeToRayBefore = max(0.0, distanceToIntersection(probeSpaceRay, directionFromProbeBefore));

  for (float d = 0.0f; d <= texCoordDistance; d += texCoordStep) {
    Point2 texCoord = (texCoordDirection * min(d + texCoordStep * 0.5, texCoordDistance)) + startTexCoord;

    int savedDepthAndNormalBytes =
        floatBitsToInt(imageLoad(probeImages, ivec3(TEX_SIZE * texCoord, probeIndex)).y);// TODO: check the coords
    float distanceFromProbeToSurface = depthFromProbe(savedDepthAndNormalBytes);

    float probeNormalEncoded1 =
        float((savedDepthAndNormalBytes >> (NORMALS_SHIFT + NORMAL1_SHIFT)) & NORMAL_ELEMENT_MASK) / NORMAL_ELEMENT_MAX;
    float probeNormalEncoded2 =
        float((savedDepthAndNormalBytes >> (NORMALS_SHIFT + NORMAL2_SHIFT)) & NORMAL_ELEMENT_MASK) / NORMAL_ELEMENT_MAX;
    vec3 normal = decodeNormal(vec2(probeNormalEncoded1, probeNormalEncoded2));

    // Find the corresponding point in probe space. This defines a line through the
    // probe origin
    vec3 directionFromProbe = octDecode(texCoord * 2.0 - 1.0);

    Point2 texCoordAfter = (texCoordDirection * min(d + texCoordStep, texCoordDistance)) + startTexCoord;
    vec3 directionFromProbeAfter = octDecode(texCoordAfter * 2.0 - 1.0);
    float distanceFromProbeToRayAfter = max(0.0, distanceToIntersection(probeSpaceRay, directionFromProbeAfter));
    float maxDistFromProbeToRay = max(distanceFromProbeToRayBefore, distanceFromProbeToRayAfter);

    if (maxDistFromProbeToRay >= distanceFromProbeToSurface) {
      // At least a one-sided hit; see if the ray actually passed through the surface, or was behind it

      float minDistFromProbeToRay = min(distanceFromProbeToRayBefore, distanceFromProbeToRayAfter);

      // Find the 3D point *on the trace ray* that corresponds to the tex coord.
      // This is the intersection of the ray out of the probe origin with the trace ray.
      float distanceFromProbeToRay = (minDistFromProbeToRay + maxDistFromProbeToRay) * 0.5;

      // Use probe information
      Point3 probeSpaceHitPoint = distanceFromProbeToSurface * directionFromProbe;
      float distAlongRay = dot(probeSpaceHitPoint - probeSpaceRay.origin, probeSpaceRay.direction);

      // Only extrude towards and away from the view ray, not perpendicular to it
      // Don't allow extrusion TOWARDS the viewer, only away
      float surfaceThickness = minThickness
          + (maxThickness - minThickness) *

              // Alignment of probe and view ray
              max(dot(probeSpaceRay.direction, directionFromProbe), 0.0) *

              // Alignment of probe and normal (glancing surfaces are assumed to be thicker because they extend into the pixel)
              (2 - abs(dot(probeSpaceRay.direction, normal))) *

              // Scale with distance along the ray
              clamp(distAlongRay * 0.1, 0.05, 1.0);

      if ((minDistFromProbeToRay < distanceFromProbeToSurface + surfaceThickness)
          /*&& (dot(normal, probeSpaceRay.direction) < 0)*/) {
        // Two-sided hit
        // Use the probe's measure of the point instead of the ray distance, since
        // the probe is more accurate (floating point precision vs. ray march iteration/oct resolution)
        tMax = distAlongRay;
        hitProbeTexCoord = texCoord;

        return TRACE_RESULT_HIT;
      } else {
        // "Unknown" case. The ray passed completely behind a surface. This should trigger moving to another
        // probe and is distinguished from "I successfully traced to infinity"

        // Back up conservatively so that we don't set tMin too large
        Point3 probeSpaceHitPointBefore = distanceFromProbeToRayBefore * directionFromProbeBefore;
        float distAlongRayBefore = dot(probeSpaceHitPointBefore - probeSpaceRay.origin, probeSpaceRay.direction);

        // Max in order to disallow backing up along the ray (say if beginning of this texel is before tMin from probe switch)
        // distAlongRayBefore in order to prevent overstepping
        // min because sometimes distAlongRayBefore > distAlongRay
        tMin = max(tMin, min(distAlongRay, distAlongRayBefore));

        return TRACE_RESULT_UNKNOWN;
      }
    }
    distanceFromProbeToRayBefore = distanceFromProbeToRayAfter;
  }// ray march

  return TRACE_RESULT_MISS;
}

bool traceSegmentLowRes(in Ray probeSpaceRay, in ProbeIndex probeIndex, inout Point2 texCoord,
                        in Point2 segmentEndTexCoord, inout Point2 endHighResTexCoord) {

  vec2 lowResSize = vec2(TEX_SIZE_SMALL);
  vec2 lowResInvSize = vec2(INV_TEX_SIZE_SMALL);

  // Convert the texels to pixel coordinates:
  Point2 P0 = texCoord * lowResSize;
  Point2 P1 = segmentEndTexCoord * lowResSize;

  // If the line is degenerate, make it cover at least one pixel
  // to avoid handling zero-pixel extent as a special case later
  P1 += vec2((distanceSquared(P0, P1) < 0.0001) ? 0.01 : 0.0);
  // In pixel coordinates
  vec2 delta = P1 - P0;

  // Permute so that the primary iteration is in x to reduce
  // large branches later
  bool permute = false;
  if (abs(delta.x) < abs(delta.y)) {
    // This is a more-vertical line
    permute = true;
    delta = delta.yx;
    P0 = P0.yx;
    P1 = P1.yx;
  }

  float stepDir = sign(delta.x);
  float invdx = stepDir / delta.x;
  vec2 dP = vec2(stepDir, delta.y * invdx);

  vec3 initialDirectionFromProbe = octDecode(texCoord * 2.0 - 1.0);
  float prevRadialDistMaxEstimate = max(0.0, distanceToIntersection(probeSpaceRay, initialDirectionFromProbe));
  // Slide P from P0 to P1
  float end = P1.x * stepDir;

  float absInvdPY = 1.0 / abs(dP.y);

  // Don't ever move farther from texCoord than this distance, in texture space,
  // because you'll move past the end of the segment and into a different projection
  float maxTexCoordDistance = lengthSquared(segmentEndTexCoord - texCoord);

  for (Point2 P = P0; ((P.x * sign(delta.x)) <= end);) {

    Point2 hitPixel = permute ? P.yx : P;

    float sceneRadialDistMin =
        float(floatBitsToUint(imageLoad(probeImagesSmall, ivec3(hitPixel, probeIndex)).x)) / DEPTH_MAX * TMP_FAR;

    // Distance along each axis to the edge of the low-res texel
    vec2 intersectionPixelDistance = (sign(delta) * 0.5 + 0.5) - sign(delta) * fract(P);

    // abs(dP.x) is 1.0, so we skip that division
    // If we are parallel to the minor axis, the second parameter will be inf, which is fine
    float rayDistanceToNextPixelEdge = min(intersectionPixelDistance.x, intersectionPixelDistance.y * absInvdPY);

    // The exit coordinate for the ray (this may be *past* the end of the segment, but the
    // callr will handle that)
    endHighResTexCoord = (P + dP * rayDistanceToNextPixelEdge) * lowResInvSize;
    endHighResTexCoord = permute ? endHighResTexCoord.yx : endHighResTexCoord;

    if (lengthSquared(endHighResTexCoord - texCoord) > maxTexCoordDistance) {
      // Clamp the ray to the segment, because if we cross a segment boundary in oct space
      // then we bend the ray in probe and world space.
      endHighResTexCoord = segmentEndTexCoord;
    }

    // Find the 3D point *on the trace ray* that corresponds to the tex coord.
    // This is the intersection of the ray out of the probe origin with the trace ray.
    vec3 directionFromProbe = octDecode(endHighResTexCoord * 2.0 - 1.0);
    float distanceFromProbeToRay = max(0.0, distanceToIntersection(probeSpaceRay, directionFromProbe));

    float maxRadialRayDistance = max(distanceFromProbeToRay, prevRadialDistMaxEstimate);
    prevRadialDistMaxEstimate = distanceFromProbeToRay;

    if (sceneRadialDistMin <= maxRadialRayDistance) {
      // A conservative hit.
      //
      //  -  endHighResTexCoord is already where the ray would have LEFT the texel
      //     that created the hit.
      //
      //  -  texCoord should be where the ray entered the texel
      texCoord = (permute ? P.yx : P) * lowResInvSize;
      return true;
    }

    // Ensure that we step just past the boundary, so that we're slightly inside the next
    // texel, rather than at the boundary and randomly rounding one way or the other.
    const float epsilon = 0.001;// pixels
    P += dP * (rayDistanceToNextPixelEdge + epsilon);
  }// for each pixel on ray

  // If exited the loop, then we went *past* the end of the segment, so back up to it (in practice, this is ignored
  // by the caller because it indicates a miss for the whole segment)
  texCoord = segmentEndTexCoord;

  return false;
}

TraceResult traceRaySegment(Ray probeSpaceRay, float t0, float t1, ProbeIndex probeIndex, inout float tMin,
                            inout float tMax, inout vec2 hitCoord) {
  vec3 probeSpaceStartPoint = probeSpaceRay.origin + probeSpaceRay.direction * (t0 + rayBumpEpsilon);
  vec3 probeSpaceEndPoint = probeSpaceRay.origin + probeSpaceRay.direction * (t1 - rayBumpEpsilon);

  // If the original ray origin is really close to the probe origin, then probeSpaceStartPoint will be close to zero
  // and we get NaN when we normalize it. One common case where this can happen is when the camera is at the probe
  // center. (The end point is also potentially problematic, but the chances of the end landing exactly on a probe
  // are relatively low.) We only need the *direction* to the start point, and using probeSpaceRay.direction
  // is safe in that case.
  if (squaredLength(probeSpaceStartPoint) < 0.001) { probeSpaceStartPoint = probeSpaceRay.direction; }

  Point2 startOctCoord = octEncode(normalize(probeSpaceStartPoint));
  Point2 endOctCoord = octEncode(normalize(probeSpaceEndPoint));

  Point2 texCoord = startOctCoord * 0.5 + 0.5;
  Point2 segmentEndTexCoord = endOctCoord * 0.5 + 0.5;
  while (true) {
    vec2 endTexCoord;
    vec2 originalStartCoord = texCoord;

    if (!traceSegmentLowRes(probeSpaceRay, probeIndex, texCoord, segmentEndTexCoord, endTexCoord)) {
      return TRACE_RESULT_MISS;
    } else {
      TraceResult traceResult =
          traceSegmentHighRes(probeSpaceRay, texCoord, endTexCoord, probeIndex, tMin, tMax, hitCoord);
      if (traceResult != TRACE_RESULT_MISS) { return traceResult; }
      vec2 texCoordRayDirection = normalize(segmentEndTexCoord - texCoord);
      if (dot(texCoordRayDirection, segmentEndTexCoord - endTexCoord) <= INV_TEX_SIZE.x) {
        return TRACE_RESULT_MISS;
      } else {
        texCoord = endTexCoord + texCoordRayDirection * INV_TEX_SIZE.x * 0.1;
      }
    }
  }
  return TRACE_RESULT_MISS;
}

TraceResult traceProbe(ProbeIndex probeIndex, Ray ray, inout float tMin, inout float tMax, inout vec2 hitCoord) {
  Point3 probeOrigin = probeLocation(probeIndex);

  Ray probeSpaceRay;
  probeSpaceRay.origin = ray.origin - probeOrigin;
  probeSpaceRay.direction = ray.direction;

  float boundaryTs[5];
  computeRaySegments(probeSpaceRay.origin, vec3(1.0) / probeSpaceRay.direction, tMin, tMax, boundaryTs);

  for (int i = 0; i < 4; ++i) {
    float t0 = boundaryTs[i];
    float t1 = boundaryTs[i + 1];

    TraceResult traceResult = traceRaySegment(probeSpaceRay, t0, t1, probeIndex, tMin, tMax, hitCoord);
    if (traceResult == TRACE_RESULT_HIT) { return TRACE_RESULT_HIT; }
    if (traceResult == TRACE_RESULT_UNKNOWN) { return TRACE_RESULT_UNKNOWN; }
  }
  return TRACE_RESULT_MISS;
}

//const ProbeIndex DEBUG_PROBE = 6;
void test_OLD() {
  ProbeIndex DEBUG_PROBE = debug.debugInt;

  ivec2 dimensions = imageSize(debugProbeImage);
  Ray worldSpaceRay;
  const vec2 uv = normalizeScreenCoords(vec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), vec2(dimensions));
  const vec4 nearPlanePos = vec4(uv, 0, 1) * camera.near;
  worldSpaceRay.origin = (camera.invProjView * nearPlanePos).xyz;
  worldSpaceRay.direction = normalize(
      (camera.invProjView * vec4(uv * (camera.far - camera.near), camera.far + camera.near, camera.far - camera.near))
          .xyz);

  Point3 probeOrigin = probeLocation(DEBUG_PROBE);

  Ray probeSpaceRay;
  probeSpaceRay.origin = worldSpaceRay.origin - probeOrigin;
  probeSpaceRay.direction = worldSpaceRay.direction;

  float tMin = 0;
  float tMax = 10;

  float boundaryTs[5];
  computeRaySegments(probeSpaceRay.origin, vec3(1.0) / probeSpaceRay.direction, tMin, tMax, boundaryTs);

  vec3 col = vec3(1);
  vec2 hitCoord;
  TraceResult traceResult = traceProbe(DEBUG_PROBE, worldSpaceRay, tMin, tMax, hitCoord);
  if (traceResult == TRACE_RESULT_HIT) {
    uint savedColorBytes = floatBitsToUint(imageLoad(probeImages, ivec3(hitCoord * TEX_SIZE, DEBUG_PROBE)).x);
    col = vec3(float(savedColorBytes & MASK11) / R_MAX, float((savedColorBytes >> G_SHIFT) & MASK11) / G_MAX,
               float((savedColorBytes >> B_SHIFT) & MASK10) / B_MAX);
  } else if (traceResult == TRACE_RESULT_UNKNOWN) {
    col = vec3(1, 0, 0);
  }
  imageStore(debugProbeImage, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), vec4(col, 1));
}

bool isRayInsideCube(ProbeIndex index, vec3 origin) {
  const vec3 bMin = probeLocation(index);
  const vec3 bMax = bMin + grid.gridStep;
  const vec3 p = origin;

  return bMin.x <= p.x && bMin.y <= p.y && bMin.z <= p.z && bMax.x >= p.x && bMax.y >= p.y && bMax.z >= p.z;
}

void test() {

  ivec2 dimensions = imageSize(debugProbeImage);
  Ray worldSpaceRay;
  const vec2 uv = normalizeScreenCoords(vec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), vec2(dimensions));
  const vec4 nearPlanePos = vec4(uv, 0, 1) * camera.near;
  worldSpaceRay.origin = (camera.invProjView * nearPlanePos).xyz;
  worldSpaceRay.direction = normalize(
      (camera.invProjView * vec4(uv * (camera.far - camera.near), camera.far + camera.near, camera.far - camera.near))
          .xyz);

  vec3 probeCoords;
  float tMin = 0;
  float tMax = 10;
  vec2 hitCoord;
  bool isUnknown = false;
  ProbeIndex hitProbeIndex = -1;
  ProbeIndex baseProbeIndex = nearestProbeIndex(worldSpaceRay.origin, probeCoords);
  CycleIndex probeIndexInCube = nearestProbeIndices(worldSpaceRay.origin);
  uint cubeCnt = 0;
  bool isMiss = false;
  /*for (int i = 0; i < grid.gridSize.x * grid.gridSize.y * grid.gridSize.z; ++i) {
    ProbeIndex probeIndex = i;
    TraceResult traceResult = traceProbe(probeIndex, worldSpaceRay, tMin, tMax, hitCoord);
    if (traceResult != TRACE_RESULT_UNKNOWN) {
      isMiss = traceResult == TRACE_RESULT_MISS;
      if (traceResult == TRACE_RESULT_HIT) {
        hitProbeIndex = probeIndex;
        isUnknown = false;
      }
      break;
    }
  }*/
  while (true) {
    ProbeIndex probeIndex = relativeProbeIndex(baseProbeIndex, probeIndexInCube);
    TraceResult traceResult = traceProbe(probeIndex, worldSpaceRay, tMin, tMax, hitCoord);
    if (traceResult != TRACE_RESULT_UNKNOWN) {
      isMiss = traceResult == TRACE_RESULT_MISS;
      if (traceResult == TRACE_RESULT_HIT) {
        hitProbeIndex = probeIndex;
        isUnknown = false;
      }
      break;
    }

    if (isRayInsideCube(baseProbeIndex, worldSpaceRay.origin + worldSpaceRay.direction * tMin)) {
      if (++cubeCnt == 8) { break; }
      probeIndexInCube = nextCycleIndex(probeIndexInCube);
    } else {
      cubeCnt = 0;
      ProbeIndex newBaseProbeIndex =
          nearestProbeIndex(worldSpaceRay.origin + worldSpaceRay.direction * tMin, probeCoords);
      if (baseProbeIndex == newBaseProbeIndex) { break; }
      baseProbeIndex = newBaseProbeIndex;
      probeIndexInCube = nearestProbeIndices(worldSpaceRay.origin + worldSpaceRay.direction * tMin);
    }
  }

  /* vec3 probeCoords;
  ProbeIndex baseProbeIndex = nearestProbeIndex(worldSpaceRay.origin, probeCoords);
  ProbeIndex hitProbeIndex = -1;
  CycleIndex nearestProbeInCube = nearestProbeIndices(worldSpaceRay.origin);
  int probesLeft = 8;
  float tMin = 0;
  float tMax = 10;
  vec2 hitCoord;
  bool isUnknown = false;
  while (probesLeft > 0) {
    ProbeIndex probeIndex = relativeProbeIndex(baseProbeIndex, nearestProbeInCube);
    TraceResult traceResult = traceProbe(probeIndex, worldSpaceRay, tMin, tMax, hitCoord);
    if (traceResult == TRACE_RESULT_UNKNOWN) {
      nearestProbeInCube = nextCycleIndex(nearestProbeInCube);
      isUnknown = true;
      --probesLeft;
    } else {
      if (traceResult == TRACE_RESULT_HIT) {
        hitProbeIndex = probeIndex;
        isUnknown = false;
      }
      break;
    }
  }*/
  /*if (hitProbeIndex == -1 && fillHoles) {

  }*/

  vec3 col = vec3(1, 0, 0);
  if (isMiss) { col = vec3(0, 1, 0); }
  if (hitProbeIndex != -1) {
    uint savedColorBytes = floatBitsToUint(imageLoad(probeImages, ivec3(hitCoord * TEX_SIZE, hitProbeIndex)).x);
    col = vec3(float(savedColorBytes & MASK11) / R_MAX, float((savedColorBytes >> G_SHIFT) & MASK11) / G_MAX,
               float((savedColorBytes >> B_SHIFT) & MASK10) / B_MAX);
  } else if (isUnknown) {
    col = vec3(1, 0, 0);
  }
  imageStore(debugProbeImage, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), vec4(col, 1));
}

void main() {
  ivec3 probeTextureSize = imageSize(probeImages);
  if (gl_GlobalInvocationID.x > probeTextureSize.x || gl_GlobalInvocationID.y > probeTextureSize.y) { return; }

  if (debug.probeVisualType == PROBE_VISUAL_TYPE_DISABLED) { return; }

  if (debug.probeVisualType == PROBE_VISUAL_TYPE_CAMERA_VIEW) {
    test();
    /* ivec2 dimensions = imageSize(debugProbeImage);
    Ray ray;
    const vec2 uv = normalizeScreenCoords(vec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), vec2(dimensions));
    const vec4 nearPlanePos = vec4(uv, 0, 1) * camera.near;
    ray.origin = (camera.invProjView * nearPlanePos).xyz;
    ray.direction = normalize(
        (camera.invProjView * vec4(uv * (camera.far - camera.near), camera.far + camera.near, camera.far - camera.near))
            .xyz);

    float tMax = 1.0;
    vec3 color = vec3(1, 1, 1);
    vec2 hitTexCoord;
    ProbeIndex hitProbeIndex;
    if (trace(ray, tMax, hitTexCoord, hitProbeIndex, true)) {
      uint savedColorBytes = floatBitsToUint(imageLoad(probeImages, ivec3(hitTexCoord * dimensions, hitProbeIndex)).x);
      color = vec3(float(savedColorBytes & MASK11) / R_MAX, float((savedColorBytes >> G_SHIFT) & MASK11) / G_MAX,
                   float((savedColorBytes >> B_SHIFT) & MASK10) / B_MAX);
    }*/
    /*if (traceResult.traceResult == TRACE_RESULT_MISS) {
      color = vec3(1, 0, 0);
    } else if (traceResult.traceResult == TRACE_RESULT_HIT) {
      color = vec3(0, 1, 0);
    } else if (traceResult.traceResult == TRACE_RESULT_UNKNOWN) {
      color = vec3(0, 0, 1);
    }
    if (traceResult.hit && false) {
      uint savedColorBytes = floatBitsToUint(
          imageLoad(probeImages, ivec3((traceResult.hitTexCoord + 0.5) * dimensions, traceResult.probeIndex)).x);
      color = vec3(float(savedColorBytes & MASK11) / R_MAX, float((savedColorBytes >> G_SHIFT) & MASK11) / G_MAX,
                   float((savedColorBytes >> B_SHIFT) & MASK10) / B_MAX);
    }*/
    //imageStore(debugProbeImage, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), vec4(color, 1));

    return;
  }

  uint savedColorBytes = floatBitsToUint(
      imageLoad(probeImages, ivec3(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y, debug.probeToRender)).x);
  const vec3 probeColor =
      vec3(float(savedColorBytes & MASK11) / R_MAX, float((savedColorBytes >> G_SHIFT) & MASK11) / G_MAX,
           float((savedColorBytes >> B_SHIFT) & MASK10) / B_MAX);

  int savedDepthAndNormalBytes = floatBitsToInt(
      imageLoad(probeImages, ivec3(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y, debug.probeToRender)).y);

  float probeDepth = float(savedDepthAndNormalBytes & DEPTH_MASK) / DEPTH_MAX;

  float probeNormalEncoded1 =
      float((savedDepthAndNormalBytes >> (NORMALS_SHIFT + NORMAL1_SHIFT)) & NORMAL_ELEMENT_MASK) / NORMAL_ELEMENT_MAX;
  float probeNormalEncoded2 =
      float((savedDepthAndNormalBytes >> (NORMALS_SHIFT + NORMAL2_SHIFT)) & NORMAL_ELEMENT_MASK) / NORMAL_ELEMENT_MAX;
  vec3 probeNormal = decodeNormal(vec2(probeNormalEncoded1, probeNormalEncoded2));
  if (debug.probeVisualType == PROBE_VISUAL_TYPE_COLOR) {
    imageStore(debugProbeImage, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), vec4(probeColor, 1));
  } else if (debug.probeVisualType == PROBE_VISUAL_TYPE_NORMALS) {
    imageStore(debugProbeImage, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y),
               vec4(probeNormal * 0.5f + 0.5f, 1));
  } else if (debug.probeVisualType == PROBE_VISUAL_TYPE_DEPTH) {
    imageStore(debugProbeImage, ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y),
               vec4(probeDepth, probeDepth, probeDepth, 1));
  }
}