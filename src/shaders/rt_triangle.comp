#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

layout(local_size_x = 4, local_size_y = 4) in;
layout(binding = 0, rgba8) uniform image2D computeImage;

layout(binding = 1) uniform UniformCamera {
    vec4 pos;
    vec4 dir;
}
camera;

#define PI 3.141592
#define Inf 10000000000000.0
#define Epsilon 0.001

#define MaxBounces 40
#define SHADOW 0.35

#define MAT_NORMAL 1
#define MAT_REFLECT 2
#define MAT_REFRACT 3

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct Material {
    vec3 color;
    int type;
};

struct Box {
    vec4 pos;
};

struct Plane {
    vec3 normal;
    float leng;

    Material mat;
};

struct Sphere {
    vec3 position;
    float radius;

    Material mat;
};

Box boxes[1] = Box[1](Box(vec4(0, -1, 0, 0)));

Sphere spheres[12] = Sphere[12](Sphere(vec3(0.0, 0.0, 10.0), 0.5, Material(vec3(1.0, 0.0, 0.0), MAT_NORMAL)),
Sphere(vec3(10.0, 0.0, 0.0), 0.5, Material(vec3(0.0, 1.0, 0.0), MAT_NORMAL)),
Sphere(vec3(0.0, 0.0, -10.0), 0.5, Material(vec3(0.0, 0.0, 1.0), MAT_NORMAL)),
Sphere(vec3(-10.0, 0.0, 0.0), 0.5, Material(vec3(1.0, 0.0, 1.0), MAT_NORMAL)),

Sphere(vec3(10.0, 0.0, 10.0), 0.5, Material(vec3(1.0, 0.0, 0.0), MAT_REFLECT)),
Sphere(vec3(10.0, 0.0, -10.0), 0.5, Material(vec3(0.0, 1.0, 0.0), MAT_REFLECT)),
Sphere(vec3(-10.0, 0.0, 10.0), 0.5, Material(vec3(0.0, 0.0, 1.0), MAT_REFLECT)),
Sphere(vec3(-10.0, 0.0, -10.0), 0.5, Material(vec3(1.0, 0.0, 1.0), MAT_REFLECT)),

Sphere(vec3(10.0, -3.0, 10.0), 0.5, Material(vec3(1.0, 0.0, 0.0), MAT_REFRACT)),
Sphere(vec3(10.0, -3.0, -10.0), 0.5, Material(vec3(0.0, 1.0, 0.0), MAT_REFRACT)),
Sphere(vec3(-10.0, -3.0, 10.0), 0.5, Material(vec3(0.0, 0.0, 1.0), MAT_REFRACT)),
Sphere(vec3(-10.0, -3.0, -10.0), 0.5, Material(vec3(1.0, 0.0, 1.0), MAT_REFRACT)));
Plane planes[1] = Plane[1](Plane(vec3(0.0, -1.0, 0.0), 1.0, Material(vec3(1.0, 1.0, 0.0), MAT_NORMAL)));
float time = 1.0;

//////////////////////////////

vec3 Camera(in float x, in float y) {
    ivec2 dimensions = imageSize(computeImage);
    float w = dimensions.x;
    float h = dimensions.y;

    float fovX = PI / 4;
    float fovY = (h / w) * fovX;

    float _x = ((2 * x - w) / w) * tan(fovX);
    float _y = -((2 * y - h) / h) * tan(fovY);

    return vec3(_x, _y, -1.0);
}

vec3 getCameraRayDir(vec2 coord, vec3 camPos, vec3 camForward) {
    const vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));
    const vec3 camUp = normalize(cross(camForward, camRight));
    const float fPersp = 1;
    return normalize(coord.x * camRight + coord.y * camUp + camForward * fPersp);
}

vec2 normalizeScreenCoords(vec2 screenCoord, vec2 resolution) {
    vec2 result = 2.0 * (screenCoord / resolution.xy - 0.5);
    result.x *= resolution.x / float(resolution.y);
    return result;
}

float PlaneIntersection(in Ray ray, in Plane plane) {
    float d0 = dot(plane.normal, ray.direction);

    if (d0 != 0) {
        float t = -1 * (((dot(plane.normal, ray.origin)) + plane.leng) / d0);
        return (t > Epsilon) ? t : 0;
    }

    return 0;
}

float SphereIntersection(in Ray ray, in Sphere sphere) {
    vec3 delta = ray.origin - sphere.position;
    float b = dot((delta * 2), ray.direction);
    float c = dot(delta, delta) - (sphere.radius * sphere.radius);

    float disc = b * b - 4 * c;
    if (disc < 0) return 0;
    else
    disc = sqrt(disc);

    // Always 2 solutions when pulling the square root.
    float result1 = -b + disc;
    float result2 = -b - disc;

    return (result2 > Epsilon) ? result2 / 2 : ((result1 > Epsilon) ? result1 / 2 : 0);
}

bool inBoxBounds(vec3 corner, float size, vec3 position) {
    bool inside = true;
    //Put the position in the coordinate frame of the box
    position -= corner;
    //The point is inside only if all of it's components are inside
    for (int i = 0; i < 3; i++) {
        inside = inside && (position[i] > -Epsilon);
        inside = inside && (position[i] < size + Epsilon);
    }

    return inside;
}

float BoxIntersection(in Ray ray, in Box box) {
    //calculate opposite corner
    vec3 corner0 = box.pos.xyz;
    vec3 corner1 = corner0 + vec3(1);

    //Set the ray plane intersections
    float coeffs[6];
    coeffs[0] = (corner0.x - ray.origin.x) / (ray.direction.x);
    coeffs[1] = (corner0.y - ray.origin.y) / (ray.direction.y);
    coeffs[2] = (corner0.z - ray.origin.z) / (ray.direction.z);
    coeffs[3] = (corner1.x - ray.origin.x) / (ray.direction.x);
    coeffs[4] = (corner1.y - ray.origin.y) / (ray.direction.y);
    coeffs[5] = (corner1.z - ray.origin.z) / (ray.direction.z);

    float t = 1.f / 0.f;
    //Check for the smallest valid intersection distance
    for (uint i = 0; i < 6; i++) {
        t = coeffs[i] >= 0 && inBoxBounds(corner0, 1, ray.origin + ray.direction * coeffs[i]) ? min(coeffs[i], t) : t;
    }

    return t;
}

vec3 GetSphereNormal(in vec3 hitPos, in Sphere sphere) { return (hitPos - sphere.position) / sphere.radius; }

bool TryGetIntersection(in Ray ray, out int id, out float distance, out bool sphere) {
    id = -1;
    distance = Inf;

    for (int i = 0; i < planes.length(); i++) {
        Plane p = planes[i];
        float dist = PlaneIntersection(ray, p);
        if (dist > Epsilon && dist < distance) {
            distance = dist;
            id = i;
            sphere = false;
        }
    }

    for (int i = 0; i < spheres.length(); i++) {
        Sphere s = spheres[i];
        float dist = SphereIntersection(ray, s);
        if (dist > Epsilon && dist < distance) {
            distance = dist;
            id = i;
            sphere = true;
        }
    }

    for (int i = 0; i < boxes.length(); i++) {
        Box s = boxes[i];
        float dist = BoxIntersection(ray, s);
        if (dist > Epsilon && dist < distance) {
            distance = dist;
            id = i;
            sphere = true;
        }
    }

    return (id > -1) ? true : false;
}

float GetShadow(in Ray ray, in int id, in bool isSphere, in float maxDist) {
    float distance = Inf;

    for (int i = 0; i < planes.length(); i++) {
        Plane p = planes[i];
        if (!isSphere && i == id) continue;

        float dist = PlaneIntersection(ray, p);
        if (dist > Epsilon && dist < distance) { distance = dist; }
    }
    for (int i = 0; i < spheres.length(); i++) {
        Sphere s = spheres[i];
        if (isSphere && i == id) continue;

        float dist = SphereIntersection(ray, s);
        if (dist > Epsilon && dist < distance) { distance = dist; }
    }

    if (distance < maxDist) return SHADOW;

    return 1.0;
}

void ReflectRay(inout Ray ray, in vec3 hitNormal, in Material mat) {
    // Specular BRDF
    if (mat.type == MAT_REFLECT) {
        float cost = dot(ray.direction, hitNormal);
        vec3 direction = (ray.direction - hitNormal * (cost * 2));
        ray.direction = normalize(direction);
    }
}

void RefractRay(inout Ray ray, in vec3 hitNormal, in Material mat) {
    if (mat.type == MAT_REFRACT) {
        float eta = 1.1;
        if (dot(ray.direction, hitNormal) < 0) ray.direction = refract(ray.direction, hitNormal, 1.0 / eta);
        else
        ray.direction = refract(ray.direction, -hitNormal, eta);
    }
}

vec3 lightPos() { return vec3(0, -10, 0); }

vec3 Light(in vec3 hitPoint) {
    if ((abs(hitPoint.y - 2.95) < 0.1) && hitPoint.x >= -0.6 && hitPoint.x <= 0.6 && hitPoint.z <= -3.05
    && hitPoint.z >= -3.45)
    return vec3(50, 50, 50);

    return vec3(0, 0, 0);
}
//////////////////////////////

vec3 Trace(inout Ray ray, out vec3 hitNormal) {
    vec3 finalColor = vec3(1.0);
    float multiplier = 1.0;

    for (int i = 0; i < MaxBounces; i++) {
        int id;
        float dist;
        bool isSphere;// Is the hitted object a sphere, or a plane ?
        bool intersection = TryGetIntersection(ray, id, dist, isSphere);
        if (!intersection) {
            finalColor *= vec3(1.0) * multiplier;
            break;
        }

        Sphere s = spheres[id];
        Plane p = planes[id];
        vec3 hitPoint = ray.origin + ray.direction * dist;
        ray.origin = hitPoint;
        hitNormal = (isSphere) ? GetSphereNormal(hitPoint, s) : p.normal;

        Material mat = (isSphere) ? s.mat : p.mat;

        vec3 emission = Light(hitPoint);
        if (length(emission) > Epsilon) return finalColor * emission * multiplier;

        ReflectRay(ray, hitNormal, mat);
        RefractRay(ray, hitNormal, mat);

        if (mat.type == MAT_NORMAL) {
            vec3 lightDir = normalize(lightPos() - hitPoint);
            float lightAttenuation = clamp(dot(hitNormal, lightDir), 0.1, 1.0);

            finalColor = finalColor * lightAttenuation * mat.color * multiplier;

            // Shadow Ray
            Ray shadowRay;
            shadowRay.origin = hitPoint;
            shadowRay.direction = lightDir;
            float maxDist = length(lightPos() - hitPoint);

            finalColor *= GetShadow(shadowRay, id, isSphere, maxDist) * multiplier;
            //

            break;
        } else {
            vec3 addColor = vec3(multiplier);
            vec3 lightDir = normalize(lightPos() - hitPoint);
            float lightAttenuation = clamp(dot(hitNormal, lightDir), 0.1, 1.0);

            addColor = addColor * lightAttenuation * mat.color;

            // Shadow Ray
            Ray shadowRay;
            shadowRay.origin = hitPoint;
            shadowRay.direction = lightDir;
            float maxDist = length(lightPos() - hitPoint);

            addColor *= GetShadow(shadowRay, id, isSphere, maxDist);
            finalColor += addColor;
            multiplier *= 0.9;
        }
    }

    return finalColor;
}

void main() {
    uint idx = gl_GlobalInvocationID.x;
    uint idy = gl_GlobalInvocationID.y;

    ivec2 dimensions = imageSize(computeImage);

    Ray ray;
    ray.origin = camera.pos.xyz;
    ray.direction = getCameraRayDir(normalizeScreenCoords(vec2(idx, idy), vec2(dimensions)), ray.origin, camera.dir.xyz);

    //vec3 cam = Camera(idx, idy);
    //ray.direction = normalize((cam - ray.origin));

    vec3 finalColor = vec3(0.0);
    vec3 hitNormal;
    finalColor = Trace(ray, hitNormal);

    finalColor = vec3(clamp(finalColor.x, 0.0, 1.0), clamp(finalColor.y, 0.0, 1.0), clamp(finalColor.z, 0.0, 1.0));

    imageStore(computeImage, ivec2(gl_GlobalInvocationID.xy), vec4(finalColor, 0.0));
}