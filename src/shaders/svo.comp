#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

#define PI 3.141592
#define INF 10000000000000.0
#define EPSILON 0.001

#define MAX_BOUNCES 40
#define SHADOW 0.35

struct Ray
{
    vec3 origin;
    float originSize;
    vec3 direction;
    float directionSize;
};


struct ChildDescriptor {
    uint childData;
    uint contourData;
};

#define LOCAL_SIZE_X 8
#define LOCAL_SIZE_Y 8

layout (local_size_x = LOCAL_SIZE_X, local_size_y = LOCAL_SIZE_Y) in;

layout (binding = 0, rgba8) uniform image2D computeImage;
layout (binding = 5, r32f) uniform image2D iterImage;

layout(binding = 1) uniform UniformCamera {
    vec4 pos;
    vec4 dir;
} camera;
layout (binding = 2) uniform UniformLigtValues {
    vec4 pos;
    vec4 ambientColor;
    vec4 diffuseColor;
    vec4 specularColor;
} light;
layout(std430, binding = 3) buffer VoxelSVO_SSBO {
    uint infoSectionPtr;
    uint attachmentsPtr;
    uint childDescriptors[];
};
#define COLOR_VIEW 0
#define NORMAL_VIEW 1
#define ITER_VIEW 2
#define DISTANCE_VIEW 3
#define CHILD_INDEX_VIEW 4
#define TREE_LEVEL_VIEW 5
layout(binding = 4) uniform UniformViewType {
    int viewType;
    int debugVal;
    int shadows;
};

float max(vec3 v) {
    return max(max(v.x, v.y), v.z);
}
float max(vec4 v) {
    return max(max(max(v.x, v.y), v.z), v.a);
}

float min(vec3 v) {
    return min(min(v.x, v.y), v.z);
}
float min(vec4 v) {
    return min(min(min(v.x, v.y), v.z), v.a);
}


    /*********************** STACK ******************************/
    #define STACK_SIZE 23
    #define CAST_STACK_DEPTH STACK_SIZE
struct StackData {
    int node;
    float tMax;
    uint offset;
};

StackData stack[STACK_SIZE + 1];

#define READ_STACK(stack, idx) stack[idx]
#define WRITE_STACK(stack, idx, n, tmax, o) stack[idx].node = n; stack[idx].tMax = tmax; stack[idx].offset = o


struct LameStackData {
    uint sideLen;
    vec3 pos;
};

LameStackData lameStack[STACK_SIZE + 1];

#define READ_LAME_STACK(stack, idx) stack[idx]
#define WRITE_LAME_STACK(stack, idx, sl, p) stack[idx].sideLen = s; stack[idx].pos = p
/************************************************************/
#define RED vec3(1, 0, 0)
#define BLUE vec3(0, 0, 1)

vec3 getCameraRayDir(vec2 coord, vec3 camPos, vec3 camForward) {
    const vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));
    const vec3 camUp = normalize(cross(camForward, camRight));
    const float fPersp = 1;
    return normalize(coord.x * camRight + coord.y * camUp + camForward * fPersp) * 500;
}

vec2 normalizeScreenCoords(vec2 screenCoord, vec2 resolution) {
    vec2 result = 2.0 * (screenCoord/resolution.xy - 0.5);
    result.x *= resolution.x/float(resolution.y);
    return result;
}

struct Box {
    vec3 pos;
    float sideLen;
};

float boxIntersection(in Ray ray, in Box box) {
    vec3 b1 = box.pos;
    vec3 b2 = b1 + box.sideLen;
    bool intersect = true;
    float t1, t2, temp, tnear = -1000.0f, tfar = 1000.0f, tCube;
    for (int i = 0; i < 3; ++i) {
        if (ray.direction[i] == 0) {
            if (ray.origin[i] < b1[i] || ray.origin[i] > b2[i]) {
                intersect = false;
                break;
            }
        } else {
            t1 = (b1[i] - ray.origin[i]) / ray.direction[i];
            t2 = (b2[i] - ray.origin[i]) / ray.direction[i];
            if (t1 > t2) {
                temp = t1;
                t1 = t2;
                t2 = temp;
            }
            if (t1 > tnear) {
                tnear = t1;
            }
            if (t2 < tfar) {
                tfar = t2;
            }
            if (tnear > tfar || tfar < 0) {
                intersect = false;
                break;
            }
        }
    }
    if (!intersect) {
        tCube = -1;
    } else {
        tCube = tnear;
    }
    return tCube;
}



struct TraceResult {
    float distance;
    vec3 pos;
    uint node;
    uint childIdx;
    bool hit;
    float t;
    int iter;
    int stackPtr;
    vec3 color;
    vec3 normal;
    bool nearEdge;
};

#define CHILD_PTR_MASK 0xFFFE0000u


const vec3 lut[8] = vec3[8] (
vec3(0, 0, 0), // 0
vec3(1, 0, 0), // 1
vec3(0, 1, 0), // 2
vec3(1, 1, 0), // 3
vec3(0, 0, 1), // 4
vec3(1, 0, 1), // 5
vec3(0, 1, 1), // 6
vec3(1, 1, 1)// 7
);
/*
TraceResult lameTrace(Ray ray) {
    ChildDescriptor childDescriptor = childDescriptors[0];
    TraceResult result;
    result.hit = false;

    int sideLen = 4;
    uint stackIdx = 0;

    Box box;
    box.pos = vec3(0);
    box.sideLen = sideLen;
    if (boxIntersection(ray, box) != -1) {
        const uint childPtr1 = bitfieldExtract(childDescriptor.childData, 17, 15);
        const uint validMask1 = bitfieldExtract(childDescriptor.childData, 8, 8);
        if (validMask1 != 0) {
            Box box1;
            box1.sideLen = box.sideLen / 2;
            for (uint i1 = 0; i1 < 8; ++i1) {
                if ((validMask1 & (1u << i1)) != 0) {
                    box1.pos = box.pos + lut[i1] * box1.sideLen;
                    if (boxIntersection(ray, box1) != -1) {
                        result.hit = true;
                        result.pos = box1.pos;
                        break;
                    }
                }
            }
        } else {
            result.hit = false;
        }
    }



    return result;
}*/


uint c_popc8LUT[] =
{
0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8,
};

uint popc8(uint mask)
{
    return c_popc8LUT[mask & 0xFFu];
}

    #define MAX_RAYCAST_ITERATIONS 10000

TraceResult trace(Ray ray) {
    const float epsilon = exp2(-CAST_STACK_DEPTH);
    float ray_orig_sz = ray.originSize;
    int iter = 0;

    ray.direction.x = abs(ray.direction.x) > epsilon ? ray.direction.x : (ray.direction.x >= 0 ? epsilon : -epsilon);
    ray.direction.y = abs(ray.direction.y) > epsilon ? ray.direction.y : (ray.direction.y >= 0 ? epsilon : -epsilon);
    ray.direction.z = abs(ray.direction.z) > epsilon ? ray.direction.z : (ray.direction.z >= 0 ? epsilon : -epsilon);

    vec3 t_coef = 1.f / -abs(ray.direction);

    vec3 t_bias = t_coef * ray.origin;


    int octant_mask = 7;
    if (ray.direction.x > 0.0f) { octant_mask ^= 1; t_bias.x = 3.0f * t_coef.x - t_bias.x; }
    if (ray.direction.y > 0.0f) { octant_mask ^= 2; t_bias.y = 3.0f * t_coef.y - t_bias.y; }
    if (ray.direction.z > 0.0f) { octant_mask ^= 4; t_bias.z = 3.0f * t_coef.z - t_bias.z; }

    float t_min = max(2.f * t_coef - t_bias);
    float t_max = min(t_coef - t_bias);
    float h = t_max;
    t_min = max(t_min, 0.0f);
    t_max = min(t_max, 1.0f);

    int   parent            = 0;
    uint  nodeOffset        = 0;
    ChildDescriptor child_descriptor = ChildDescriptor(0, 0);// invalid until fetched
    int    idx              = 0;
    vec3 pos                = vec3(1.0f, 1.0f, 1.0f);
    int    scale            = CAST_STACK_DEPTH - 1;
    float  scale_exp2       = 0.5f;// exp2f(scale - s_max)

    if (1.5f * t_coef.x - t_bias.x > t_min) { idx ^= 1; pos.x = 1.5f; }
    if (1.5f * t_coef.y - t_bias.y > t_min) { idx ^= 2; pos.y = 1.5f; }
    if (1.5f * t_coef.z - t_bias.z > t_min) { idx ^= 4; pos.z = 1.5f; }

    TraceResult res;
    res.nearEdge = false;
    vec3 color = vec3(0);
    bool fetch = true;

    while (scale < CAST_STACK_DEPTH)
    {
        iter++;
        if (iter > MAX_RAYCAST_ITERATIONS)
        break;

        // Fetch child descriptor unless it is already valid.

        //if (child_descriptor.childData == 0)
        if (fetch)
        {
            child_descriptor.childData = childDescriptors[parent];
            //child_descriptor.contourData = childDescriptors[parent + 1];
            fetch = false;
        }

        vec3 t_corner = pos * t_coef - t_bias;
        float tc_max = min(t_corner);

        int child_shift = idx ^ octant_mask;// permute child slots based on the mirroring
        uint child_masks = child_descriptor.childData << child_shift;
        if ((child_masks & 0x8000u) != 0 && t_min <= t_max)
        {
            // Terminate if the voxel is small enough.
            //if (tc_max * ray.directionSize + ray_orig_sz >= scale_exp2) {
            //    color = lut[child_shift] * 0.5 + 0.1;
            //    break;// at t_min
            //}
            //color = vec3(1, 0, 0);

            // INTERSECT
            // Intersect active t-span with the cube and evaluate
            // tx(), ty(), and tz() at the center of the voxel.

            float tv_max = min(t_max, tc_max);
            float halfScale = scale_exp2 * 0.5f;
            vec3 t_center = halfScale * t_coef + t_corner;

            if (t_min <= tv_max) {
                // Terminate if the corresponding bit in the non-leaf mask is not set.
                if ((child_masks & 0x0080u) != 0) {
                    child_shift = 7 - child_shift;
                    vec3 norm, t_corner = t_coef * (pos + scale_exp2) - t_bias;
                    if (t_corner.x > t_corner.y && t_corner.x > t_corner.z) {
                        norm = vec3(-1, 0, 0);
                    } else if (t_corner.y > t_corner.z) {
                        norm = vec3(0, -1, 0);
                    } else {
                        norm = vec3(0, 0, -1);
                    }


                    if ((octant_mask & 1) == 0u) { norm.x = -norm.x; }
                    if ((octant_mask & 2) == 0u) { norm.y = -norm.y; }
                    if ((octant_mask & 4) == 0u) { norm.z = -norm.z; }
                    res.normal = norm;

                    uint lookupOffset = infoSectionPtr;
                    uint lookupEntry = childDescriptors[lookupOffset + nodeOffset];
                    uint lookupEntryMask = lookupEntry & 0xFFu;
                    uint siblingOffset = bitCount(lookupEntryMask << (8 - child_shift) & 0xFFu);
                    uint attPtr = lookupEntry >> 8u & 0xFFFFFFu;
                    attPtr += siblingOffset + attachmentsPtr;
                    uint phongAttrib = childDescriptors[attPtr];
                    color = vec3(
                    (phongAttrib >> 24u & 0xFFu) / 255.f,
                    (phongAttrib >> 16u & 0xFFu) / 255.f,
                    (phongAttrib >> 8 & 0xFFu) / 255.f
                    );
                    //color = lut[child_shift] * 0.5f + 0.5f;

                    //if ((lookupEntry & 0xFFu) != 0) {
                    //    color = RED;
                    //} else {
                    //    color = BLUE;
                    //}

                    break;// at t_min (overridden with tv_min).
                }


                // PUSH
                // Write current parent to the stack.

                if (tc_max < h) {
                    WRITE_STACK(stack, scale, parent, t_max, nodeOffset);
                }
                h = tc_max;

                // Find child descriptor corresponding to the current voxel.

                uint ptr = child_descriptor.childData >> 17u;// child pointer
                uint validMask = (child_descriptor.childData >> 8u) & 0xFFu;
                uint leafMask = child_descriptor.childData & 0xFFu;

                child_shift = 7 - child_shift;


                validMask = validMask << (8 - child_shift) & 0xFFu;
                leafMask = leafMask << (8 - child_shift) & 0xFFu;

                uint ofs = bitCount(validMask) - bitCount(leafMask);

                //uint ofs = popc8(child_masks & 0x7Fu);
                //ofs = child_masks & 0x7FFFu;


                //color = lut[ofs] * 0.5 + 0.3;
                uint offsetFromParent = ptr + ofs;
                nodeOffset = parent / 2 + offsetFromParent;
                parent = parent + int(offsetFromParent * 2);


                // Select child voxel that the ray enters first.

                idx = 0;
                scale--;
                scale_exp2 = halfScale;

                if (t_center.x > t_min) { idx ^= 1; pos.x += scale_exp2; }
                if (t_center.y > t_min) { idx ^= 2; pos.y += scale_exp2; }
                if (t_center.z > t_min) { idx ^= 4; pos.z += scale_exp2; }

                // Update active t-span and invalidate cached child descriptor.

                t_max = tv_max;
                //child_descriptor.childData = 0;
                fetch = true;
                continue;
            }
        }

        // ADVANCE
        // Step along the ray.
        int step_mask = 0;
        if (t_corner.x <= tc_max) { step_mask ^= 1; pos.x -= scale_exp2; }
        if (t_corner.y <= tc_max) { step_mask ^= 2; pos.y -= scale_exp2; }
        if (t_corner.z <= tc_max) { step_mask ^= 4; pos.z -= scale_exp2; }

        // Update active t-span and flip bits of the child slot index.

        t_min = tc_max;
        idx ^= step_mask;

        // Proceed with pop if the bit flips disagree with the ray direction.

        if ((idx & step_mask) != 0)
        {
            // POP
            // Find the highest differing bit between the two positions.

            uint differing_bits = 0;
            if ((step_mask & 1) != 0) differing_bits |= floatBitsToInt(pos.x) ^ floatBitsToInt(pos.x + scale_exp2);
            if ((step_mask & 2) != 0) differing_bits |= floatBitsToInt(pos.y) ^ floatBitsToInt(pos.y + scale_exp2);
            if ((step_mask & 4) != 0) differing_bits |= floatBitsToInt(pos.z) ^ floatBitsToInt(pos.z + scale_exp2);
            scale = findMSB(differing_bits);// position of the highest bit
            scale_exp2 = intBitsToFloat((scale - CAST_STACK_DEPTH + 127) << 23);// exp2f(scale - s_max)

            // Restore parent voxel from the stack.

            parent = READ_STACK(stack, scale).node;
            t_max = READ_STACK(stack, scale).tMax;
            nodeOffset = READ_STACK(stack, scale).offset;

            // Round cube position and extract child slot index.

            int shx = floatBitsToInt(pos.x) >> scale;
            int shy = floatBitsToInt(pos.y) >> scale;
            int shz = floatBitsToInt(pos.z) >> scale;
            pos.x = intBitsToFloat(shx << scale);
            pos.y = intBitsToFloat(shy << scale);
            pos.z = intBitsToFloat(shz << scale);
            idx  = (shx & 1) | ((shy & 1) << 1) | ((shz & 1) << 2);

            // Prevent same parent from being stored again and invalidate cached child descriptor.

            h = 0.0f;
            //child_descriptor.childData = 0;
            fetch = true;
        }
    }

    if (scale >= CAST_STACK_DEPTH || iter > MAX_RAYCAST_ITERATIONS)
    {
        t_min = 2.0f;
    }

    // Undo mirroring of the coordinate system.

    if ((octant_mask & 1) == 0) pos.x = 3.0f - scale_exp2 - pos.x;
    if ((octant_mask & 2) == 0) pos.y = 3.0f - scale_exp2 - pos.y;
    if ((octant_mask & 4) == 0) pos.z = 3.0f - scale_exp2 - pos.z;


    // Output results.

    res.t = t_min;
    res.iter = iter;
    res.pos.x = min(max(ray.origin.x + t_min * ray.direction.x, pos.x + epsilon), pos.x + scale_exp2 - epsilon);
    res.pos.y = min(max(ray.origin.y + t_min * ray.direction.y, pos.y + epsilon), pos.y + scale_exp2 - epsilon);
    res.pos.z = min(max(ray.origin.z + t_min * ray.direction.z, pos.z + epsilon), pos.z + scale_exp2 - epsilon);
    res.node = parent;
    res.childIdx = idx ^ octant_mask ^ 7;
    res.stackPtr = scale;
    res.color = color;
    res.hit = !(scale >= CAST_STACK_DEPTH || iter > MAX_RAYCAST_ITERATIONS);
    return res;
}


vec3 calcLight(TraceResult traceResult, vec3 lightDir, bool isInShadow) {
    if (isInShadow) {
        return traceResult.color * 0.01;
    }
    const vec3 pos = traceResult.pos;
    const vec3 normal = traceResult.normal;
    const float NoL = max(dot(normal, -lightDir), 0.0);
    const vec3 LAmbient = light.ambientColor.xyz;
    const vec3 LDirectional = light.diffuseColor.xyz * NoL;
    const vec3 diffuse = (LDirectional + LAmbient);
    const float specular = dot(normalize(light.pos.xyz - pos), reflect(normalize(pos - camera.pos.xyz), normal));
    vec3 intensity = diffuse + light.specularColor.xyz * (0.25 * pow(clamp(specular, 0.0, 1.0), 200.0));
    return traceResult.color * intensity;

}



void main() {
    uint idx = gl_GlobalInvocationID.x;
    uint idy = gl_GlobalInvocationID.y;

    ivec2 dimensions = imageSize(computeImage);
    if (idx > dimensions.x || idy > dimensions.y) {
        return;
    }

    float count = 0;
    vec3 finalColor = vec3(0);
    vec3 iterColor = vec3(0);
    const int AA_size = 1;
    Ray ray;
    for (float aaY = 0.0; aaY < AA_size; aaY++) {
        for (float aaX = 0.0; aaX < AA_size; aaX++) {
            vec2 uv = normalizeScreenCoords(vec2(idx, idy) + vec2(aaX, aaY) / AA_size, vec2(dimensions));
            ray.origin = camera.pos.xyz;
            ray.direction = getCameraRayDir(uv, ray.origin, camera.dir.xyz);
            ray.originSize = 0.02;
            ray.directionSize = 0;
            TraceResult traceResult = trace(ray);
            TraceResult shadowTraceResult;

            vec3 lightDir = normalize(light.pos.xyz - traceResult.pos);
            if (shadows == 1) {
                Ray shadowRay;
                shadowRay.direction = lightDir;
                shadowRay.origin = traceResult.pos + EPSILON * lightDir;
                shadowRay.originSize = 0.02;
                shadowRay.directionSize = 0;
                shadowTraceResult = trace(shadowRay);
                traceResult.iter += shadowTraceResult.iter;
            } else {
                shadowTraceResult.hit = false;
            }

            iterColor += vec3(traceResult.iter / 64.f);
            if (viewType == ITER_VIEW) {
                finalColor += vec3(traceResult.iter / 64.f);
            } else if (traceResult.hit) {
                if (viewType == COLOR_VIEW) {
                    if (traceResult.nearEdge) {
                        finalColor += RED;
                    } else {
                        finalColor += calcLight(traceResult, lightDir, shadowTraceResult.hit);
                    }
                } else if (viewType == NORMAL_VIEW) {
                    finalColor += traceResult.normal * 0.5f + 0.5f;
                } else if (viewType == DISTANCE_VIEW) {
                    finalColor += vec3(traceResult.t * 500);
                } else if (viewType == CHILD_INDEX_VIEW) {
                    finalColor += lut[traceResult.childIdx];
                } else if (viewType == TREE_LEVEL_VIEW) {
                    finalColor += lut[STACK_SIZE - traceResult.stackPtr];
                }
            }
            count += 1.0;
        }
    }
    finalColor /= count;
    iterColor /= count;



    finalColor = vec3(clamp(finalColor.x, 0.0, 1.0), clamp(finalColor.y, 0.0, 1.0), clamp(finalColor.z, 0.0, 1.0));

    imageStore(computeImage, ivec2(gl_GlobalInvocationID.xy), vec4(finalColor, 1.0));
    imageStore(iterImage, ivec2(gl_GlobalInvocationID.xy), vec4(iterColor, 1.0));

}